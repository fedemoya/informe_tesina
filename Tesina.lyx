#LyX 2.1 created this file. For more info see http://www.lyx.org/
\lyxformat 474
\begin_document
\begin_header
\textclass book
\begin_preamble
\usepackage[utf8]{inputenc}
\usepackage{textcomp}
\usepackage{alltt}
\renewcommand{\ttdefault}{txtt}
\usepackage[cm]{fullpage}
\usepackage{listings}
\lstset{language=c++, xleftmargin=25pt}
\input{listings-modelica.cfg}
\usepackage{amsmath}
\usepackage{float}
\usepackage{graphicx}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{epstopdf}
\end_preamble
\use_default_options true
\maintain_unincluded_children false
\language spanish
\language_package \usepackage[spanish]{babel}
\inputencoding utf8
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_math auto
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize 10
\spacing other 1.2
\use_hyperref true
\pdf_title "Causalización de modelos Modelica"
\pdf_author "Federico Moya"
\pdf_bookmarks true
\pdf_bookmarksnumbered true
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder true
\pdf_colorlinks true
\pdf_backref false
\pdf_pdfusetitle true
\papersize a4paper
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine natbib
\cite_engine_type numerical
\biblio_style plainnat
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 7cm
\topmargin 2cm
\rightmargin 2cm
\bottommargin 2cm
\secnumdepth 2
\tocdepth 2
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 2
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Standard
\begin_inset Phantom VPhantom
status open

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Phantom VPhantom
status open

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Phantom VPhantom
status open

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Phantom VPhantom
status open

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Phantom VPhantom
status open

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
thispagestyle{empty}
\end_layout

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout


\backslash
textbf{{
\backslash
Huge Causalización de Modelos Modelica}}
\backslash

\backslash
[0.5cm]
\end_layout

\begin_layout Plain Layout

{
\backslash
Large Tesina de Grado}
\backslash

\backslash
[2cm]
\end_layout

\begin_layout Plain Layout

{
\backslash
large Alumno: Federico Moya}
\backslash

\backslash
[1cm]
\end_layout

\begin_layout Plain Layout

{
\backslash
large Director: Federico Bergero}
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

{
\backslash
large Co-director: Ernesto Kofman}
\backslash

\backslash
[2cm]
\end_layout

\begin_layout Plain Layout


\backslash
begin{figure}[h]
\end_layout

\begin_layout Plain Layout

  
\backslash
centering
\end_layout

\begin_layout Plain Layout

  
\backslash
includegraphics[width=0.2
\backslash
textwidth]{graphics/logo_unr.jpg}
\end_layout

\begin_layout Plain Layout


\backslash
end{figure}
\end_layout

\begin_layout Plain Layout


\backslash
textbf{{
\backslash
large Licenciatura en Cs.
 de la Computación}}
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
textbf{{
\backslash
large Universidad Nacional de Rosario}}
\backslash

\backslash
[2cm]
\end_layout

\begin_layout Plain Layout


\backslash
today
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Phantom VPhantom
status open

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Phantom VPhantom
status open

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Phantom VPhantom
status open

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Phantom VPhantom
status open

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Phantom VPhantom
status open

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Phantom VPhantom
status open

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Phantom VPhantom
status open

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Phantom VPhantom
status open

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Phantom VPhantom
status open

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Phantom VPhantom
status open

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space \hfill{}
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
emph{A mis viejos, Inés y Tony, porque sin su apoyo esto no hubiese sido
 posible.}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space \hfill{}
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
emph{Al amor de mi vida, Victoria, por su enorme paciencia.}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Section*
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center} 
\end_layout

\begin_layout Plain Layout


\backslash
vspace{1.9cm}     
\backslash
huge{Resumen}
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
El modelado y simulación computacional se ha convertido en una herramienta
 fundamental para el desarrollo de la ciencia y la ingeniería.
 En general los sistemas dinámicos son descriptos matemáticamente mediante
 ecuaciones diferenciales que luego son simuladas por métodos de integración
 numérica.
 
\end_layout

\begin_layout Standard
El lenguaje de modelado orientado a objetos Modelica es el estándar de-facto
 para describir computacionalmente esta clase de modelos.
 En él se representan los sistemas dinámicos como un conjunto de ecuaciones
 diferenciales algebraicas (DAE).
 La integración de DAEs es compleja y poco robusta por lo cual las herramientas
 de Modelica convierten simbólicamente las ecuaciones DAEs en una formulación
 de ecuación diferencial ordinaria (ODE) para luego ser resultas por métodos
 de integración para ODEs.
\end_layout

\begin_layout Standard
En este trabajo se presenta la implementación de un algoritmo de causalización,
 que convierte modelos DAEs en ODEs para modelos Modelica.
 Se estudian diferentes enfoques analizando la complejidad algorítimica
 de cada una y luego se validan experimentalmente su performance computacional.
\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Part
Preliminares
\end_layout

\begin_layout Chapter
Introducción
\end_layout

\begin_layout Standard
Modelica es un lenguaje orientado a objetos, para el modelado de sistemas
 complejos, con componentes, mecánicos, eléctricos, electrónicos, hidráulicos
 y térmicos entre otros.
 El lenguaje no tiene restricciones de uso 
\begin_inset Foot
status open

\begin_layout Plain Layout
Licencia Modelica V2
\end_layout

\end_inset

 y es desarrollado por la asociación sin fines de lucro Modelica Association
\begin_inset CommandInset citation
LatexCommand citep
key "Fritzson98"

\end_inset

.
\end_layout

\begin_layout Standard
El modelado de sistemas físicos por medio de lenguajes orientados a objetos
 conduce a descripciones constituidas por ecuaciones diferenciales algebraicas,
 o de manera abreviada descripciones DAE
\begin_inset Foot
status open

\begin_layout Plain Layout
Differential algebraic equation
\end_layout

\end_inset

 
\begin_inset CommandInset citation
LatexCommand citep
key "CK06,elmqvist2005,Fritzson98"

\end_inset

.
 Aunque esto es muy útil para el modelador la mayoría de los métodos de
 integración numérica esperan un modelo en forma de ecuación diferencial
 ordinaria o descripción ODE
\begin_inset Foot
status open

\begin_layout Plain Layout
Ordinary differential equation
\end_layout

\end_inset


\begin_inset CommandInset citation
LatexCommand citep
key "FernandezKofman12"

\end_inset

.
 La conversión de un conjunto de DAEs en ODEs es lo que denominamos causalizació
n de ecuaciones.
 Dependiendo de las características de cada modelo se pueden aplicar distintos
 algoritmos para convertir descripciones DAE en descripciones ODE.
 En los casos más simples la conversión se puede realizar aplicando simples
 algoritmos de ordenación, pero en otros casos, en donde se presentan grandes
 bucles algebraicos o singularidades estructurales, es necesario aplicar
 otras técnicas más complejas.
\end_layout

\begin_layout Standard
Este trabajo se encuentra enmarcado en el desarrollo de un compilador Modelica.
 Puntualmente, el trabajo hace foco en la etapa de causalización de ecuaciones.
 Se analizan los algoritmos existentes y se presenta una implementación
 en el lenguaje C++ del componente responsable de realizar dicha tarea.
 Este componente se implementó como una aplicación independiente la cual
 espera modelos Modelica simplificados (el pipeline de compilación se describe
 en el capítulo 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Visión-general-del"

\end_inset

) y genera modelos Modelica cuyas ecuaciones se encuentran en la forma ODE,
 es decir ordenadas vertical y horizontalmente, de manera que el lado izquierdo
 de cada ecuación sea una incógnita y el lado derecho sea una expresión
 compuesta por variables conocidas, es decir variables que se resuelven
 mediante alguna ecuación anterior.
\end_layout

\begin_layout Standard
En el resto de este capítulo se introducen los conceptos básicos involucrados
 en el trabajo.
 Se definen las nociones de modelado y simulación.
 Se presenta una introducción al lenguaje Modelica así como también se describe
 brevemente la etapa de causalización.
 Se presentan los motivos y objetivos del trabajo y finalmente se detalla
 la organización del mismo.
\end_layout

\begin_layout Section
Modelado y simulación
\end_layout

\begin_layout Standard
Se dice que las computadoras están revolucionando la ciencia y la ingeniería.
 Utilizando computadores podemos construir complejos diseños ingenieriles
 como por ejemplo el de un transbordador espacial.
 Somos capaces de calcular las propiedades del universo tal como fueron
 fracciones de segundos después del big bang.
 Nuestras ambiciones incluso están creciendo.
 Queremos crear diseños más complejos como mejores naves espaciales, autos,
 medicinas, sistemas de telefonía celular computarizados, etc.
 Queremos entender aspectos más profundos de la naturaleza.
 Éstos son solo algunos ejemplos de modelado y simulación soportado por
 computadoras.
 Son necesarias herramientas y conceptos más poderosos para ayudar a manejar
 tal nivel de complejidad.
 El trabajo realizado en esta tesina se enmarca en el desarrollo de una
 herramienta de estas características.
\end_layout

\begin_layout Subsection
Sistemas y experimentos
\end_layout

\begin_layout Standard
¿Que es un sistema? Ya hemos mencionado algunos sistemas como el universo
 o un transbordador espacial.
 Un sistema puede ser casi cualquier cosa.
 Un sistema puede tener subsistemas que son a su vez sistemas.
 Una definición posible de un sistema puede ser:
\end_layout

\begin_layout Itemize
Un sistema es un objeto o una colección de objetos cuyas propiedades queremos
 estudiar.
\end_layout

\begin_layout Standard
¿Qué razones se pueden tener para estudiar un sistema? Esta pregunta puede
 tener muchas respuestas pero podemos destacar dos motivaciones principales:
\end_layout

\begin_layout Itemize
Estudiar un sistema para entenderlo y así poder construirlo.
 Este es el punto de vista de la ingeniería.
\end_layout

\begin_layout Itemize
Satisfacer la curiosidad humana, por ejemplo para saber más acerca de la
 naturaleza.
 Este es el punto de vista de las ciencias naturales.
\end_layout

\begin_layout Standard
Una propiedad importante de los sistemas es que deben ser observables.
 Algunos sistemas también son controlables en el sentido de que se puede
 influenciar su comportamiento suministrando valores de entrada, esto es:
\end_layout

\begin_layout Itemize
Las entradas son variables del entorno que influencian el comportamiento
 del sistema.
 Estas entradas pueden o no ser controlables por nosotros.
\end_layout

\begin_layout Itemize
Las salidas de un sistema son variables que son determinadas por el sistema
 y pueden influenciar el entorno que lo rodea.
\end_layout

\begin_layout Standard
En algunos sistemas las mismas variables actúan como entradas y salidas.
 Hablamos de comportamiento acausal si las relaciones o influencias entre
 las variables no poseen una dirección causal, como es el caso de las relaciones
 descriptas por ecuaciones.
 Por ejemplo, en un sistema mecánico las fuerzas del entorno influencian
 el desplazamiento de un objeto, pero por otro lado el desplazamiento del
 objeto influencia las fuerzas entre el objeto y el entorno.
 Qué se considera como entrada y qué como salida es una decisión del observador,
 basado en lo que quiere estudiar, más que una propiedad del sistema.
\end_layout

\begin_layout Standard
La observabilidad es esencial para poder estudiar un sistema de acuerdo
 con nuestra definición de sistema.
 Al menos debemos poder observar algunas salidas de un sistema.
 Vamos a aprender aún más si podemos ejercitar el sistema controlando las
 entradas.
 Este proceso se llama experimentación:
\end_layout

\begin_layout Itemize
Un experimento es el proceso de extraer información de un sistema ejercitando
 sus entradas.
\end_layout

\begin_layout Standard
Una desventaja del método experimental es que para un gran número de sistemas
 muchas variables de entrada no son accesibles ni controlables.
 Estos sistemas se encuentran bajo la influencia de entradas inaccesibles
 denominadas entradas de perturbación
\begin_inset Foot
status open

\begin_layout Plain Layout
perturbance inputs
\end_layout

\end_inset

.
 Asimismo también ocurre que algunas variables de salida importantes no
 resultan accesibles para poder medirlas; estas variables a veces se denominan
 estados internos del sistema.
 Además existen una serie de problemas prácticos relacionados con la realización
 de un experimento, a saber:
\end_layout

\begin_layout Itemize
El experimento puede ser muy caro.
\end_layout

\begin_layout Itemize
El experimento puede ser muy peligroso.
\end_layout

\begin_layout Itemize
El sistema necesario para el experimento puede que todavía no exista.
 Esto es típico de sistemas que deben ser diseñados o fabricados.
\end_layout

\begin_layout Standard
Las desventajas del método experimental nos llevan al concepto de modelo.
 Si construimos un modelo del sistema, este modelo puede ser investigado
 y puede servir para responder muchas preguntas sobre el sistema real si
 el modelo es lo suficientemente realista.
\end_layout

\begin_layout Subsubsection
Modelo
\end_layout

\begin_layout Standard
Dadas las definiciones previas de sistema y experimento podemos ahora intentar
 definir la noción de modelo:
\end_layout

\begin_layout Itemize
Un modelo de un sistema es cualquier cosa sobre la cual se puede aplicar
 un 
\begin_inset Quotes eld
\end_inset

experimento
\begin_inset Quotes erd
\end_inset

 con el objeto de responder preguntas sobre el sistema.
\end_layout

\begin_layout Standard
Esta definición implica que un modelo se puede utilizar para responder preguntas
 sobre un sistema sin tener que realizar experimentos sobre el sistema real.
 En su lugar se realizan algo así como 
\begin_inset Quotes eld
\end_inset

experimentos
\begin_inset Quotes erd
\end_inset

 simplificados sobre el modelo, el cual a su vez puede ser considerado como
 una sistema simplificado que refleja ciertas propiedades del sistema real.
\end_layout

\begin_layout Standard
Existen diferentes formas de representar un modelo:
\end_layout

\begin_layout Itemize
Modelo mental: una declaración como 
\begin_inset Quotes eld
\end_inset

esa persona es confiable
\begin_inset Quotes erd
\end_inset

 nos ayuda a responder preguntas acerca del comportamiento de esa persona
 en varias situaciones.
\end_layout

\begin_layout Itemize
Modelo verbal: este tipo de modelos se expresan en palabras.
 Por ejemplo, la oración 
\begin_inset Quotes eld
\end_inset

van a ocurrir más accidentes si se incrementa el límite de velocidad
\begin_inset Quotes erd
\end_inset

 es un ejemplo de un modelo verbal.
 Los sistemas expertos son una manera de formalizar estos modelos.
\end_layout

\begin_layout Itemize
Modelo físico: esto es un objeto físico que imita ciertas propiedades del
 sistema real para ayudar a responder ciertas preguntas sobre dicho sistema.
 Por ejemplo, durante el diseño de artefactos como edificios, aviones, etc,
 es común construir un modelo físico pequeño con la misma forma y apariencia
 que el modelo real que se pretende estudiar.
\end_layout

\begin_layout Itemize
Modelo matemático: es una descripción de un sistema en donde las relaciones
 entre las variables del sistema se expresan en forma matemática.
 Las variables pueden ser cantidades medibles como tamaño, longitud, peso,
 temperatura, nivel de desempleo, flujo de información, etc.
 La mayoría de las leyes de físicas son modelos matemáticos en este sentido.
\end_layout

\begin_layout Standard
Este trabajo trata con modelos matemáticos representados de varias maneras,
 por ejemplo como ecuaciones, funciones, programas de computadora, etc.
 
\end_layout

\begin_layout Subsubsection
Simulación
\end_layout

\begin_layout Standard
En la sección anterior mencionamos la posibilidad de realizar 
\begin_inset Quotes eld
\end_inset

experimentos
\begin_inset Quotes erd
\end_inset

 sobre modelos en lugar de hacerlo sobre los sistemas reales correspondientes
 con los modelos.
 Este es uno de los usos principales de los modelos y se denota con el término
 simulación.
 Definimos una simulación de la siguiente manera:
\end_layout

\begin_layout Itemize
Una simulación es un experimento realizado sobre un modelo.
\end_layout

\begin_layout Standard
A continuación vamos a ver algunos ejemplos de simulaciones:
\end_layout

\begin_layout Itemize
La simulación de un proceso industrial como la producción de acero o papel
 para aprender sobre el comportamiento bajo diferentes condiciones de operación
 con el objetivo de mejorar el proceso.
\end_layout

\begin_layout Itemize
La simulación del comportamiento de un vehículo, por ejemplo un auto o un
 avión, para que el conductor o piloto pueda disponer de un entrenamiento
 realista.
\end_layout

\begin_layout Itemize
La simulación de un modelo simplificado de una red de computadoras para
 aprender cómo se comporta bajo diferentes cargas con el objetivo de mejorar
 la eficiencia.
\end_layout

\begin_layout Standard
¿Dada la utilidad de la simulación a la hora de estudiar el comportamiento
 de los sistemas, cómo hacemos para construir modelos de esos sistemas?
 Existen lenguajes de modelado que facilitan la construcción de modelos
 de sistemas.
 Uno de esos lenguajes es Modelica.
 En la sección siguiente vamos a introducir este lenguaje de modelado el
 cual es parte fundamental del contexto de esta tesina.
\end_layout

\begin_layout Section
\begin_inset CommandInset label
LatexCommand label
name "sec:Modelica"

\end_inset

Modelica
\end_layout

\begin_layout Standard
Modelica es un lenguaje orientado a objetos desarrollado para describir
 de manera sencilla modelos de sistemas dinámicos eventualmente muy complejos.
\end_layout

\begin_layout Standard
Además de las características básicas de todo lenguaje orientado a objetos,
 Modelica contiene herramientas específicas que permiten describir las relacione
s constitutivas de los distintos componentes de cada modelo y las relaciones
 estructurales que definen la interacción entre dichos componentes.
\end_layout

\begin_layout Standard
De esta manera, el lenguaje permite asociar cada componente de un sistema
 a una instancia de una clase de Modelica.
 Adicionalmente, los componentes típicos de los sistemas de distintos dominios
 de la física y de la técnica pueden agruparse en librerías de clases para
 ser reutilizados.
 De hecho, existe una librería estándar de clases de Modelica, que contiene
 los principales componentes básicos de sistemas eléctricos, mecánicos (translac
ionales, rotacionales y multi-cuerpos), térmicos, state graphs, y diagramas
 de bloques.
 Otras librerías (disponibles en la web) contienen componentes de sistemas
 hidráulicos, bond graphs, redes de petri, etc.
\end_layout

\begin_layout Standard
Los modelos Modelica son acausales.
 Esto significa que son modelos basados en ecuaciones más que en asignaciones.
 La principal ventaja de este tipo de modelado es que la dirección de la
 solución de las ecuaciones es adaptable al flujo de datos del contexto
 en el que se computa.
 El flujo de datos se define estableciendo qué variables son necesarias
 como 
\shape italic
salidas
\shape default
, y cuáles son 
\shape italic
entradas
\shape default
 externas al sistema simulado.
 La acausalidad de las clases de la biblioteca de Modelica las hacen más
 reutilizables que las clases que contienen asignaciones donde la causalidad
 entrada-salida es fija.
\end_layout

\begin_layout Section
Causalización
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Revisar este párrafo
\end_layout

\end_inset

 Como se mencionó en la sección 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Modelica"

\end_inset

 los modelos Modelica son acausales.
 Esta característica de los modelos que facilita su reutilización presenta
 un desafío para el compilador el cual debe producir como salida un modelo
 donde las ecuaciones se encuentren ordenadas de manera tal que puedan ser
 resueltas secuencialmente al momento de la simulación.
\end_layout

\begin_layout Standard
Para ordenar las ecuaciones se realiza un procesamiento simbólico del modelo
 denominado causalización.
 Esta etapa del proceso de compilación constituye el tema principal de esta
 tesina.
\end_layout

\begin_layout Standard
El proceso de causalización consiste en ordenar topológicamente un conjunto
 de ecuaciones acausales de acuerdo a las dependencias del flujo de datos
 entre ellas.
 El objetivo de este ordenamiento es que las ecuaciones puedan resolverse
 de manera secuencial una después de la otra.
\end_layout

\begin_layout Standard
Para lograr la causalización de las ecuaciones de un modelo Modelica se
 utiliza un algoritmo de teoría de grafos denominado Algoritmo de Tarjan
 
\begin_inset CommandInset citation
LatexCommand citep
key "Tarjan72"

\end_inset

.
 Dicho algoritmo permite encontrar los componentes fuertementes conexos
 de un grafo.
 Este algoritmo posee la propiedad de que ningún componente fuertemente
 conexo es identificado antes que sus sucesores.
 De esta manera el orden en que los componentes fuertemente conexos son
 encontrados representa un orden topológico reverso del grafo dirigido acíclico
 formado por los componentes fuertemente conexos.
 Esta propiedad del algoritmo de Tarjan es la que lo hace apropiado para
 resolver el problema de causalización de ecuaciones.
 En la sección 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Aplicación-Tarjan-Boost"

\end_inset

 mostramos cómo se aplica este algoritmo en el contexto de un compilador
 Modelica.
\end_layout

\begin_layout Section
Motivación, Objetivos, y Trabajo Relacionado
\end_layout

\begin_layout Standard
El presente trabajo se enmarca dentro del proyecto de investigación 
\begin_inset Quotes eld
\end_inset

Modelado, Simulación y Control en Tiempo Real con Aplicaciones en Electrónica
 de Potencia
\begin_inset Quotes erd
\end_inset

 de la Universidad Nacional de Rosario.
\end_layout

\begin_layout Standard
Uno de los objetivos del proyecto es el desarrollo de un compilador para
 el lenguaje de modelado Modelica 
\begin_inset CommandInset citation
LatexCommand citep
key "Fritzson98"

\end_inset

 con los fines de investigar distintos algoritmos en relación a modelos
 de gran escala.
 Existen diversas herramientas de modelado y simulación Modelica libres
 como OpenModelica 
\begin_inset CommandInset citation
LatexCommand citep
key "Fri05"

\end_inset

, JModelica 
\begin_inset CommandInset citation
LatexCommand citep
key "jmod"

\end_inset

.
 Aunque estas herramientas son software libre la experimentación con nuevos
 algoritmos no resulta sencilla, ya sea porque están programadas en un lenguaje
 propio como es el caso de OpenModelica o porque la inclusión de código
 experimental las volvería más inestables.
\end_layout

\begin_layout Standard
Por este fin se planteó el desarrollo de un compilador de Modelica propio
 sobre el cual desarrollar y probar los nuevos algoritmos.
\end_layout

\begin_layout Standard
En este trabajo se describe la implementación de un componente de dicho
 compilador cuya tarea es la causalización de ecuaciones diferenciales algebraic
as.
 Esta implementación, si bien no maneja los modelos de gran escala de manera
 óptima (porque expande los arreglos y las estructuras repetitivas ver sección
 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Expansión-de-ecuaciones"

\end_inset

), constituye el puntapié inicial para una implementación futura, en donde,
 se realice la causalización de ecuaciones sin la necesidad de expandir
 los arreglos ni las estructuras repetitivas presentes en el modelo.
 Una implementación de este tipo se puede ver en el siguiente artículo 
\begin_inset CommandInset citation
LatexCommand citep
key "lsmodelica"

\end_inset

.
\end_layout

\begin_layout Section
Organización del trabajo
\end_layout

\begin_layout Standard
En la Parte I se presenta el contexto en el que se realizó el trabajo.
 En el capítulo 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Marco-teórico"

\end_inset

 vamos a encontrar el marco teórico donde se introducen los conceptos de
 ecuación diferencial algebraica y ecuación diferencial ordinaria.
 Luego introducimos los aspectos principales del lenguaje Modelica junto
 con las técnicas númericas y simbólicas que se utilizan para simular modelos
 Modelica.
 Una de estas técnicas es la causalización de ecuaciones.
 Finalmente en el capítulo 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Visión-general-del"

\end_inset

 se describen los diferentes componentes que componen el compilador Modelica
 C Compiler (ModelicaCC).
\end_layout

\begin_layout Standard
En la Parte II del trabajo se presentan las contribuciones.
 El detalle de la implementación del componente 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+causalize+
\end_layout

\end_inset

 se encuentra en el capítulo 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Implementación-etapa-de"

\end_inset

.
 En el capítulo 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Ejemplos"

\end_inset

 se presenta a modo de ejemplo la aplicación del componente de causalización
 sobre dos modelos pertenecientes al dominio de la ingeniería eléctrica.
 En el capítulo 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Prueba-de-eficiencia"

\end_inset

 se puede encontrar un caso de estudio a partir del cual se comparan las
 estrategias de causalización implementadas.
 En el capítulo 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Tests-unitarios"

\end_inset

 se encuentra el detalle de los tests unitarios implementados.
 Finalmente en el capítulo 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Conclusiones"

\end_inset

 se presentan las conclusiones y el trabajo a futuro.
\end_layout

\begin_layout Chapter
\begin_inset CommandInset label
LatexCommand label
name "chap:Marco-teórico"

\end_inset

Marco teórico
\end_layout

\begin_layout Section
Modelos Matemáticos para Sistemas Continuos
\end_layout

\begin_layout Standard
En esta sección vamos a ver un repaso de diferentes tipos de ecuaciones
 y variables presentes en modelos matemáticos de sistemas continuos.
\end_layout

\begin_layout Subsection
Categorías de variables y constantes
\end_layout

\begin_layout Standard
Antes de comenzar a describir los distintos tipos de ecuaciones resulta
 conveniente definir los diferentes tipos de variables y constantes que
 se pueden encontrar en las ecuaciones.
\end_layout

\begin_layout Standard
A continuación vamos a ver una lista de definiciones de variables y constantes
 asumiendo diferentes roles en los modelos matemáticos.
 Estos roles usualmente no son una propiedad del modelo o del sistema modelado
 sino una consecuencia de la combinación del modelo, algunos experimentos
 o simulación y condiciones dadas a partir de lo que queremos estudiar.
 Sin embargo, hay que tener en cuenta que los modelos pueden ser formulados
 de manera más o menos genérica o reutilizable.
 Un modelo acausal basado en ecuaciones se ajusta a varios contextos de
 flujo de datos diferentes donde las variables asumen diferentes roles,
 p.
 ej.
 como entrada o salida, mientras que un modelo en donde las variables han
 sido fijadas como entradas o salidas solo se ajusta a algunas pocas configuraci
ones de experimentación.
\end_layout

\begin_layout Itemize

\series bold
Constante:
\series default
 una cantidad en el modelo que no varía nunca, por ejemplo la gravedad en
 la tierra 
\begin_inset ERT
status open

\begin_layout Plain Layout

$g=9.8$
\end_layout

\end_inset

.
\end_layout

\begin_layout Itemize

\series bold
Parámetro de modelo:
\series default
 una constante en el modelo que es determinada por el sistema, o una constante
 que puede ser modificada con el fin de darle diferentes propiedades al
 sistema.
 Permance constante durante la simulación pero puede ser modificado entre
 ejecuciones.
\end_layout

\begin_layout Itemize

\series bold
Variable:
\series default
 una cantidad en el modelo que varia respecto del tiempo.
\end_layout

\begin_layout Itemize

\series bold
Variable de salida:
\series default
 una variable cuyo comportamiento queremos observar.
 Usualmente denotada como 
\begin_inset Formula $y(t)$
\end_inset

.
 El rol de variable de salida no está establecido por el sistema que se
 modela sino que es determinado por lo que el modelador quiere estudiar.
 No obstante es frecuente que también queramos observar algunas variables
 de estado (ver debajo).
\end_layout

\begin_layout Itemize

\series bold
Variable de entrada:
\series default
 una variable que afecta el comportamiento del modelo sin ser afectada por
 otras variables del modelo y cuyas variaciones respecto del tiempo pueden
 ser controladas.
 Usualmente se las denota 
\begin_inset Formula $u(t)$
\end_inset

.
\end_layout

\begin_layout Itemize

\series bold
Variable de estado
\series default
: una variable que no es ni de entrada ni de salida y que aparece su derivada
 respecto del tiempo, usualmente denotada por 
\begin_inset Formula $\dot{x}(t)$
\end_inset


\begin_inset Foot
status open

\begin_layout Plain Layout
Cabe aclarar que el análisis es puramente sintáctico.
 Es decir el algoritmo de causalización no realiza ningún analisis de tipo
 semantico.
 Por ejemplo, en el hipotético caso de un sistema en el cual aparece la
 ecuación 
\begin_inset Formula $\dot{x}(t)=\dot{x}(t)$
\end_inset

, la variable 
\begin_inset Formula $x$
\end_inset

 va a ser considerada de estado por el algoritmo de causalización.
 No obstante, existe un componente del compilador ModelicaCC, denominado
 antialias, el cual se encarga de eliminar ecuaciones de este tipo.
 En el capítulo 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Visión-general-del"

\end_inset

 vamos a ver en más detalle los diferentes componentes que componen el compilado
r ModelicaCC.
\end_layout

\end_inset

.
 Si queremos estudiar alguna variable de estado 
\begin_inset Formula $x_{i}(t)$
\end_inset

 siempre podemos agregar una variable de salida asociada 
\begin_inset Formula $y_{j}(t)$
\end_inset

 junto con la ecuación 
\begin_inset Formula $y_{j}(t)=x_{i}(t)$
\end_inset

, o directamente observar la variable de estado.
 Cabe aclarar que para modelos que contengan singularidades estructurales
 las variables de estados serán un subconjunto de las cuales aparecen derivadas
 pero por el resto de este trabajo nos enfocaremos en sistemas 
\emph on
sin singularidades estructurales
\emph default

\begin_inset Foot
status open

\begin_layout Plain Layout
Un modelo presenta singularidades estructurales si el orden del sistema
 es mayor que los grados de libertad del mismo 
\begin_inset CommandInset citation
LatexCommand citep
key "CK06"

\end_inset

.
 
\end_layout

\end_inset

.
\end_layout

\begin_layout Itemize

\series bold
Variables algebraicas:
\series default
 una variable que aparece en las ecuaciones pero que su derivada no aparece
 en el modelo.
\end_layout

\begin_layout Subsection
Tipos de ecuaciones presente en modelos matemáticos
\end_layout

\begin_layout Standard
Previamente hemos definido una variable de estado como una variable para
 la cual su derivada respecto del tiempo aparece en el modelo.
 Existe una formulación estándar de las ecuaciones de ciertos modelos matemático
s de sistemas dinámicos denominada modelos de espacio de estados explícitos,
 en donde las derivadas de las variables de estado aparecen explícitamente
 del lado izquierdo de las ecuaciones.
\end_layout

\begin_layout Standard
Estos modelos son atractivos como una representación matemática básica dado
 que usualmente resultan más eficientes de resolver y analizar que otros
 modelos más complicados, sirviendo a la vez para representar un espectro
 amplio de aplicaciones.
 Sin embargo hay que tener en cuenta que muchos modelos no pueden ser transforma
dos directamente a la forma de espacio de estados explicito sino que primero
 deben aplicarse algoritmos de reducción de índice (como el de Pantelides
 
\begin_inset CommandInset citation
LatexCommand citep
key "Pan88"

\end_inset

)
\end_layout

\begin_layout Subsection
Ecuaciones diferenciales ordinarias - Espacio de Estados
\end_layout

\begin_layout Standard
La forma básica de ecuaciones continuas ODE en forma de espacio de estados
 explícita se presenta debajo, donde 
\begin_inset Formula $x($
\end_inset

t) es el conjunto de variables de estados, 
\begin_inset Formula $u(t)$
\end_inset

 representa las variables de entrada, e 
\begin_inset Formula $y(t)$
\end_inset

 representa las variables de salida y/o las algebraicas.
 Un modelo en forma de espacio de estados explícita se define como 
\begin_inset Formula 
\begin{gather}
\dot{x}(t)=f(x(t),u(t))\nonumber \\
y(t)=g(x(t),u(t))\label{eq:ode}
\end{gather}

\end_inset


\end_layout

\begin_layout Standard
Aquí 
\begin_inset Formula $\dot{x}(t)$
\end_inset

, 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
\lang english

\begin_inset Formula $u(t)$
\end_inset


\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
\lang spanish
 y 
\begin_inset Formula $y(t)$
\end_inset

 son vectores y 
\begin_inset Formula $f$
\end_inset

 y 
\begin_inset Formula $g$
\end_inset

 son funciones vectoriales.
 Las ecuaciones diferenciales ordinarias (o ODEs por sus siglas en inglés)
 aparecen en la mayoría de los modelos matemáticos de sistemas continuos
 dado que la dependencia respecto del tiempo en esos modelos generalmente
 se refleja por medio de derivadas respecto del tiempo de variables de estado
 correspondientes a dichos modelos.
 Por ejemplo, la ley de fuerza de Newton, la cual establece que la fuerza
 
\begin_inset Formula $F(t)$
\end_inset

 es igual a la masa 
\begin_inset Formula $m$
\end_inset

 por la segunda derivada 
\begin_inset Formula $\ddot{s}(t)$
\end_inset

 de la posición 
\begin_inset Formula $s(t)$
\end_inset

 con respecto al tiempo, es un ejemplo de ODE de segundo orden:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{gather*}
\begin{aligned}m\ddot{s}(t)\end{aligned}
=F(t)
\end{gather*}

\end_inset


\end_layout

\begin_layout Standard
Introduciendo una variable 
\begin_inset Formula $v(t)$
\end_inset

 nos podemos deshacer de la segunda derivada.
 Después de reacomodar la primer ecuación tenemos a todas las derivadas
 del lado izquierdo y todas son derivadas de primer orden.
 Esto significa que hemos transformado el sistema en uno ODE explícito de
 primer orden:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{gather*}
\dot{v}(t)=\frac{F(t)}{m}\\
\dot{s}(t)=v(t)
\end{gather*}

\end_inset


\end_layout

\begin_layout Standard
Un sistema ODE de esta forma es especialmente eficiente para resolver númericame
nte.
\end_layout

\begin_layout Subsection
Ecuaciones algebraicas
\end_layout

\begin_layout Standard
Las ecuaciones algebraicas son relaciones entre variables que no involucran
 derivadas de ninguna variable.
 Estas ecuaciones aparecen naturalmente en modelos de sistemas naturales
 o artificiales, especialmente cuando hay involucrada alguna restricción.
\end_layout

\begin_layout Standard
Por ejemplo, las coordenadas cartesianas 
\begin_inset Formula $\{x,y\}$
\end_inset

 de la masa en el péndulo de la figura 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:pendulo}
\end_layout

\end_inset

 satisfacen la siguiente ecuación algebraica donde se establece que la longitud
 del péndulo es 
\begin_inset Formula $L$
\end_inset

 según la ley de Pitágoras:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{gather*}
x^{2}+y^{2}=L^{2}
\end{gather*}

\end_inset


\end_layout

\begin_layout Standard
Las variables definidas por ecuaciones algebraicas y cuyas derivadas no
 aparecen en el modelo se denominan variables algebraicas.
 Alguna de estas variables también pueden ser variables de salida.
\end_layout

\begin_layout Standard
La forma general de un sistema de ecuaciones algebraicas (sin incluir ecuaciones
 diferenciales) es se puede ver a continuación:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{gather*}
G(x(t),u(t),y(t))=0
\end{gather*}

\end_inset


\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "sub:Ecuaciones-diferenciales-algebra"

\end_inset

Ecuaciones diferenciales algebraicas
\end_layout

\begin_layout Standard
Un sistema de ecuaciones algebraico (DAE, por sus siglas en inglés) incluye
 tanto ecuaciones diferenciales como ecuaciones algebraicas.
 Por ejemplo, el sistema que vemos en la figura 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:pendulo}
\end_layout

\end_inset

, el cual corresponde a un péndulo plano, se modela mediante ecuaciones
 diferenciales algebraicas.
 El sistema de ecuaciones se puede ver a continuación: 
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{gather}
m\dot{v_{x}}=-F\sin(\varphi)\nonumber \\
m\dot{v_{y}}=-F\cos(\varphi)-mg\nonumber \\
\dot{x}=v_{x}\nonumber \\
\dot{y}=v_{y}\label{eq:pendulo}\\
\dot{\varphi}=\omega\nonumber \\
x=L\sin(\varphi)\nonumber \\
y=-L\cos\left(\varphi\right)\nonumber 
\end{gather}

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{figure}[h]
\end_layout

\begin_layout Plain Layout

  
\backslash
centering
\end_layout

\begin_layout Plain Layout

  
\backslash
includegraphics[width=0.2
\backslash
textwidth]{graphics/pendulum.png}
\end_layout

\begin_layout Plain Layout

  
\backslash
caption{Péndulo plano}
\end_layout

\begin_layout Plain Layout

  
\backslash
label{fig:pendulo}
\end_layout

\begin_layout Plain Layout


\backslash
end{figure}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Cinco de las ecuaciones del modelo son diferenciales y dos son algebraicas.
 Las variables del modelo son 
\begin_inset Formula $x$
\end_inset

, 
\begin_inset Formula $y$
\end_inset

, 
\begin_inset Formula $v_{x}$
\end_inset

, 
\begin_inset Formula $v_{y}$
\end_inset

, 
\begin_inset Formula $\varphi$
\end_inset

, 
\begin_inset Formula $\omega$
\end_inset

, 
\begin_inset Formula $F$
\end_inset

 y las constantes 
\begin_inset Formula $L$
\end_inset

, 
\begin_inset Formula $m$
\end_inset

, 
\begin_inset Formula $g$
\end_inset

.
 Hemos reemplazado la ecuación correspondiente a la ley de Pitagóras por
 dos ecuaciones algebraicas sobre las variables 
\begin_inset Formula $x$
\end_inset

 e 
\begin_inset Formula $y$
\end_inset

 respectivamente, las cuales aún preservan la restricción sobre la longitud
 del péndulo.
\end_layout

\begin_layout Standard
La forma general de un sistema DAE, de la cual el ejemplo anterior es un
 caso particular donde 
\begin_inset Formula $x=\{x,y,v_{x},v_{y},\varphi\}$
\end_inset

, 
\begin_inset Formula $u=\{\}$
\end_inset

, 
\begin_inset Formula $y=\{$
\end_inset


\begin_inset Formula $\omega,F\}$
\end_inset

, se puede ver a continuación:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{gather}
F(x(t),\dot{x}(t),u(t),y(t))=0\nonumber \\
G(x(t),u(t),y(t))=0\label{eq:dae}
\end{gather}

\end_inset


\end_layout

\begin_layout Subsection
Simulación de Modelos Continuos
\end_layout

\begin_layout Standard
En la sección anterior vimos como modelar matemáticamente sistemas dinámicos
 como ecuaciones diferenciales explícitas (ODEs) o algebraicas (DAEs).
 
\end_layout

\begin_layout Standard
Desde el punto de vista del modelador, describir el sistema en forma de
 DAE como la ecuación (
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:dae"

\end_inset

) resulta más sencillo (o incluso la única forma de hacerlo) debido a que
 partiendo de un modelo de primeros principios se pueden describir las relacione
s constitutivas de cada componente y las inter-relaciones entre éstos.
 Por otro lado la simulación computacional de esta clase de modelos conlleva
 ciertos problemas.
 Primero se deben encontrar condiciones iniciales consistentes que satisfagan
 todas las ecuaciones lo cual no es sencillo.
 Luego, si el sistema contiene singularidades estructurales, algunas variables
 se deberán resolver integrando su derivada y otras derivando la variable.
 La derivación numérica no es robusta 
\begin_inset CommandInset citation
LatexCommand citep
key "CK06"

\end_inset

 por lo cual sólo se usa en casos particulares.
\end_layout

\begin_layout Standard
En el caso general se prefiere recurrir a métodos de integración para ODEs
 ya que éstos siempre integran todas las variables de estado.
 Es por ello que los modelos descriptos como DAEs deben ser convertidos
 simbólicamente a ODEs.
 Esta conversión es lo que se conoce como 
\emph on
causalización
\emph default
 de un modelo y es la cuestión central de este trabajo.
 Se verá en detalle en la sección 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Transformación-BLT--"

\end_inset

.
\end_layout

\begin_layout Section
El lenguaje Modelica
\end_layout

\begin_layout Standard
Modelica es un lenguaje de modelado (estándar abierto) que permite la especifica
ción de modelos matemáticos de complejos sistemas naturales o artificiales
 con el propósito de posibilitar la simulación computarizada de sistemas
 dinámicos que evolucionan con el tiempo.
 Modelica es también un lenguaje de programación orientado a objetos y basado
 en ecuaciones, pensado para aplicaciones de mucha complejidad que requieren
 una alta eficiencia.
 Las tres características principales son:
\end_layout

\begin_layout Itemize
Modelica está principalmente basado en ecuaciones en lugar de asignaciones.
 Esto permite un modelado acausal lo cual facilita la reutilización de las
 clases ya que las ecuaciones no especifican una dirección particular para
 el flujo de datos.
 De esta manera una clase Modelica se puede adaptar a contextos con diferentes
 flujos de datos.
\end_layout

\begin_layout Itemize
Modelica permite describir y conectar componentes de modelos pertenecientes
 a diferentes dominios como eléctricos, mecánicos, termodinámica, hidráulica,
 biología, control, etc.
\end_layout

\begin_layout Itemize
Modelica es un lenguaje orientado a objetos con un concepto general de clase
 que unifica las ideas de clases, tipos genéricos y subtipos en un solo
 lenguaje.
 Esto facilita la reutilización de componentes y la evolución de los modelos.
\end_layout

\begin_layout Standard
Estas son las propiedades que hacen a Modelica un lenguaje potente y fácil
 de utilizar, especialmente para modelado y simulación.
\end_layout

\begin_layout Subsection
Modelado matemático orientado a objetos
\end_layout

\begin_layout Standard
Los lenguajes orientados a objetos tradicionales como Smalltalk, Java o
 C++, así como también los lenguajes procedurales como Fortran o C, soportan
 la programación sobre datos almacenados en memoria.
 Los datos almacenados en memoria corresponde a valores de variables y datos
 de objetos.
 El número de objetos usualmente cambia de manera dinámica.
 El enfoque de orientación a objetos de Smalltalk enfatiza el envío de mensajes
 entre objetos.
\end_layout

\begin_layout Standard
El enfoque de Modelica del concepto de orientación a objetos es diferente
 ya que Modelica enfatiza el modelado matemático estructurado.
 La orientación a objetos es vista como una forma de estructuración para
 poder manejar la complejidad de las descripciones de grandes sistemas.
 Un Modelo Modelica es principalmente una descripción matemática declarativa.
 Las propiedades de los sistemas dinámicos se expresan de manera declarativa
 mediante ecuaciones.
 
\end_layout

\begin_layout Standard
El enfoque declarativo de Modelica sobre la orientación a objetos se puede
 resumir en estos puntos:
\end_layout

\begin_layout Itemize
La orientación a objetos es utilizada como un concepto de estructuración,
 enfatizando la estructura declarativa y la reutilización de los modelos
 matemáticos.
 Las tres maneras de estructurar son jerarquías, conexiones entre componentes
 y herencia.
\end_layout

\begin_layout Itemize
Las propiedades de los modelos dinámicos se expresan de manera declarativa
 utilizando ecuaciones.
\end_layout

\begin_layout Itemize
Un objeto es una colección de variables de instancia y ecuaciones que comparten
 un conjunto de datos.
\end_layout

\begin_layout Standard
No obstante
\end_layout

\begin_layout Itemize
La orientación a objetos en el modelado matemático no es considerado como
 un intercambio de mensajes entre objetos.
\end_layout

\begin_layout Standard
La forma declarativa y orientada a objetos de describir sistemas y su comportami
ento que ofrece Modelica es de un nivel más alto de abstracción del que
 poseen los lenguajes orientados a objetos tradicionales ya que ciertos
 detalles de implementación se omiten.
 Por ejemplo, no es necesario escribir código para transportar datos de
 un objeto a otro mediante asignaciones.
 Ese código lo genera automáticamente el compilador de Modelica a partir
 de las ecuaciones dadas.
\end_layout

\begin_layout Standard
De la misma manera que ocurre en los lenguajes orientados a objetos ordinarios
 las clases son plantillas para la creación de objetos.
 Tanto variables como ecuaciones pueden ser heredadas entre clases.
 También las definiciones de funciones pueden ser heredadas.
 No obstante, la especificación de comportamiento se realiza principalmente
 mediante ecuaciones en lugar de métodos.
 También el lenguaje permite escribir código en forma de algoritmos incluyendo
 funciones pero esto es una excepción más que una regla.
\end_layout

\begin_layout Standard
Dado que este trabajo se centra en la etapa de causalización y que en ese
 momento del proceso de compilación el modelo ya se encuentra aplanado,
 es decir solo se compone de variables de tipos básicos y ecuaciones, no
 ahondaremos más en las particularidades del sistema de clases de Modelica.
 El lector interesado puede consultar en 
\begin_inset CommandInset citation
LatexCommand citep
key "Fritzson98"

\end_inset

.
\end_layout

\begin_layout Subsection
Conceptos básicos
\end_layout

\begin_layout Standard
Un modelo Modelica se construye a partir de clases, también denominadas
 modelos.
 A partir de la definición de una clase es posible crear cualquier número
 de objetos que se conocen como instancias de esa clase.
\end_layout

\begin_layout Standard
Una clase Modelica contiene elementos, los principales son declaraciones
 de variables y ecuaciones; las ecuaciones se agrupan en secciones.
 Las variables contienen datos pertenecientes a instancias de una clase.
 Las ecuaciones de una clase especifican el comportamiento de las instancias
 de dicha clase.
\end_layout

\begin_layout Standard
La tradición establece que el primer programa de ejemplo cualquiera sea
 el lenguaje de programación es un programa sencillo que simplemente imprime
 la cadena de caracteres 
\begin_inset Quotes eld
\end_inset

Hello World
\begin_inset Quotes erd
\end_inset

.
 Dado que Modelica es un lenguaje de modelado basado en ecuaciones, imprimir
 una cadena de caracteres no tiene mucho sentido.
 En su lugar nuestro primer 
\emph on
modelo
\emph default
 Modelica resuelve una ecuación diferencial trivial.
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\dot{x}(t)=-a\times x(t)
\]

\end_inset


\end_layout

\begin_layout Standard
La variable 
\begin_inset Formula $x(t)$
\end_inset

 en esta ecuación es una variable dinámica cuyo valor puede variar con el
 transcurso del tiempo.
 La expresión 
\begin_inset Formula $\dot{x(t)}$
\end_inset

 es la derivada temporal de 
\begin_inset Formula $x$
\end_inset

, lo cual en Modelica se representa como 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+der(x)+
\end_layout

\end_inset

.
 Dado que todos los programas en Modelica, llamados modelos, consisten en
 declaraciones de clases nuestro programa HelloWorld se declara como una
 clase:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}[language=Modelica]
\end_layout

\begin_layout Plain Layout

class HelloWorld
\end_layout

\begin_layout Plain Layout

  Real x(start = 1);
\end_layout

\begin_layout Plain Layout

  parameter Real a = 1;
\end_layout

\begin_layout Plain Layout

  equation
\end_layout

\begin_layout Plain Layout

    der(x) = -a*x;
\end_layout

\begin_layout Plain Layout

end HelloWorld;
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
El programa contiene la declaración de una clase llamada 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+HelloWorld+
\end_layout

\end_inset

 con una variable, un parámetro y una sola ecuación.
 El primer atributo de la clase es la variable 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+x+
\end_layout

\end_inset

, la cual es inicializada al valor 1 en el momento en el que se inicia la
 simulación.
 Todas las variables en Modelica tienen un atributo 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+start+
\end_layout

\end_inset

 con un valor por defecto el cual usualmente es 0.
\end_layout

\begin_layout Standard
El segundo atributo es la variable 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+a+
\end_layout

\end_inset

 la cual es una constante inicializada a 1 al momento de iniciarse la simulación.
 Las constantes de este tipo se declaran utilizando el prefijo 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+parameter+
\end_layout

\end_inset

 para indicar que permanecen constantes durante la simulación pero que es
 un parámetro del modelo que puede tomar un valor distinto para cada simulación,
 por ejemplo mediante algún comando del entorno de simulación.
\end_layout

\begin_layout Standard
Notar también que las variables poseen un tipo que las antecede cuando se
 declaran.
 En nuestro ejemplo ambas variables poseen el tipo 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+Real+
\end_layout

\end_inset

 esto es valores que pertenecen al eje real 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
mathbf{R}$
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
La única ecuación de nuestro ejemplo especifica que la derivada temporal
 de 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+x+
\end_layout

\end_inset

 es igual a la multiplicación de 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+-a+
\end_layout

\end_inset

 por 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+x+
\end_layout

\end_inset

.
 En Modelica el signo 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+=+
\end_layout

\end_inset

 siempre significa igualdad, esto es, define una ecuación y no una asignación
 como en la mayoría de los lenguajes de programación.
 Esto es, podríamos haber descripto la misma ecuación como:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}
\end_layout

\begin_layout Plain Layout

0 = der(x) + a*x;
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
donde se ve explícitamente que no es una asignación sino una igualdad.
\end_layout

\begin_layout Standard
La derivada temporal de una variable se indica mediante la pseudo-función
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+der()+
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Nuestro segundo ejemplo es un poco más complicado, es el modelo matemático
 de un péndulo plano (ver figura 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:pendulo}
\end_layout

\end_inset

).
 Las ecuaciones del modelo son las presentadas en la sección 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Ecuaciones-diferenciales-algebra"

\end_inset

.
 El código modelica para este sistema es el que se puede ver a continuación.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}[language=Modelica]
\end_layout

\begin_layout Plain Layout

class Pendulum "Planar Pendulum"
\end_layout

\begin_layout Plain Layout

  parameter Real m=1, g=9.81, L=O.5;
\end_layout

\begin_layout Plain Layout

  Real F, phi, omega;
\end_layout

\begin_layout Plain Layout

  output Real x(start=O.5) ,y(start=O);
\end_layout

\begin_layout Plain Layout

  output Real vx,vy;
\end_layout

\begin_layout Plain Layout

  equation
\end_layout

\begin_layout Plain Layout

    m*der(vx)=-F*sin(phi);
\end_layout

\begin_layout Plain Layout

    m*der(vy)=-F*cos(phi)-m*g;
\end_layout

\begin_layout Plain Layout

    der(x)=vx;
\end_layout

\begin_layout Plain Layout

    der(y)=vy;
\end_layout

\begin_layout Plain Layout

    der(phi)=omega;
\end_layout

\begin_layout Plain Layout

    x=L*sin(phi);
\end_layout

\begin_layout Plain Layout

    y=-L*cos(phi);
\end_layout

\begin_layout Plain Layout

end Pendulum;
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Lo interesante de este modelo es que las dos últimas ecuaciones son diferentes
 al resto, son ecuaciones algebraicas, es decir, involucran solo operaciones
 algebraicas sobre las variables pero no derivadas.
 Las otras cinco ecuaciones son ecuaciones diferenciales, como la ecuación
 del ejemplo 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+HelloWorld+
\end_layout

\end_inset

.
 Los sistemas de ecuaciones que contienen tanto ecuaciones diferenciales
 como ecuaciones algebraicas se denominan sistemas de ecuaciones diferenciales
 algebraicas (o DAEs por sus siglas en inglés).
\end_layout

\begin_layout Standard
Por último hacemos una observación importante en relación a los modelos
 Modelica simulables.
\end_layout

\begin_layout Verse

\emph on
El número de variables debe ser igual al número de ecuaciones
\begin_inset Foot
status open

\begin_layout Plain Layout

\emph on
A los fines de la causalización se considera que todas las ecuaciones son
 diferentes, incluso si la misma ecuación aparece dos veces.
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Esta regla es respetada por los dos modelos que vimos en esta sección y
 debe ser respetada por cualquier modelo para ser considerado resoluble.
 Por variables nos referimos a algo que pueda variar en el tiempo, no constantes
 ni parámetros.
\end_layout

\begin_layout Subsubsection
Variables
\end_layout

\begin_layout Standard
El modelo que vamos a ver a continuación muestra un modelo levemente más
 complicado.
 El cual describe un oscilador de Van der Pol.
 Notar que en este ejemplo la palabra clave 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+model+
\end_layout

\end_inset

 se utiliza en lugar de 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+class+
\end_layout

\end_inset

 casi con el mismo significado.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}[language=Modelica]
\end_layout

\begin_layout Plain Layout

model VanDerPol "Van der Pol oscillator model"
\end_layout

\begin_layout Plain Layout

  Real x(start = 1) "Descriptive string for x";
\end_layout

\begin_layout Plain Layout

  Real y(start = 1) "Descriptive string for y";
\end_layout

\begin_layout Plain Layout

  parameter Real alpha = 0.3, beta = 0.3, gamma=0.5, delta=0.7;
\end_layout

\begin_layout Plain Layout

  equation
\end_layout

\begin_layout Plain Layout

    der(x) = x*(alpha-beta*y);
\end_layout

\begin_layout Plain Layout

    der(y) = -y*(gamma-delta*x);
\end_layout

\begin_layout Plain Layout

end VanDerPol;
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Este ejemplo contiene la declaración de dos variables dinámicas 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+x+
\end_layout

\end_inset

 e 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+y+
\end_layout

\end_inset

, ambas de tipo 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+Real+
\end_layout

\end_inset

 y con valor inicial 1 al comienzo de la simulación, lo cual normalmente
 es al momento t=0.
\end_layout

\begin_layout Standard
La palabra clave 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+parameter+
\end_layout

\end_inset

 especifica que la variable permanece constante durante la simulación, pero
 que su valor se puede inicializar antes de una ejecución o entre ejecuciones.
 Un 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+parameter+
\end_layout

\end_inset

 es una constante que permite al usuario modificar de manera sencilla el
 comportamiento de un modelo, por ejemplo modificando el parámetro 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+delta+
\end_layout

\end_inset

 el cual influencia considerablemente el comportamiento del oscilador de
 Van der Pol.
 Por el contrario, una constante Modelica declarada con el prefijo 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+constant+
\end_layout

\end_inset

 nunca cambia y puede ser sustituida por su valor en los lugares donde ocurra.
\end_layout

\begin_layout Standard
Por último hay una sección para ecuaciones declarada con la palabra clave
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+equation+
\end_layout

\end_inset

, conteniendo dos ecuaciones mutuamente dependientes que definen la dinámica
 del modelo.
\end_layout

\begin_layout Subsection
Arreglos
\end_layout

\begin_layout Standard
Un arreglo es una colección de variables todas del mismo tipo.
 Los elementos de un arreglo se acceden por medio de índices enteros cuyos
 valores van desde 1 hasta el tamaño de la respectiva dimensión.
 Una variable de tipo arreglo se puede declarar agregando dimensiones entre
 corchetes después del nombre de una clase, como en Java, o después del
 nombre de una variable, como en C.
 Por ejemplo:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}[language=Modelica]
\end_layout

\begin_layout Plain Layout

  Real[3] positionvector = {1,2,3};
\end_layout

\begin_layout Plain Layout

  Real[3,3] identitymatrix = {{1,0,0}, {0,1,0}, {0,0,1}};
\end_layout

\begin_layout Plain Layout

  Real[10,20,30] arr3d;
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Esto declara un vector, una matriz de transformación y un arreglo de tres
 dimensión 10, 20 y 30 correspondientemente.
\end_layout

\begin_layout Standard
Más detalles sobre arreglos en Modelica se pueden encontrar en 
\begin_inset CommandInset citation
LatexCommand citep
key "Fritzson:2003:POM:966262"

\end_inset

.
\end_layout

\begin_layout Subsection
Ecuaciones
\end_layout

\begin_layout Standard
Como ya hemos mencionado, Modelica es principalmente un lenguaje basando
 en ecuaciones a diferencia de los lenguajes de programación ordinarios
 donde proliferan las asignaciones.
 Las ecuaciones son más flexibles que las asignaciones dado que no determinan
 un flujo de datos u orden de ejecución particular.
 Esta es la clave de las capacidades de modelado de sistemas físicos y del
 potencial de reutilización de las clases Modelica.
\end_layout

\begin_layout Standard
Pensar en términos de ecuaciones es poco usual para la mayoría de los programado
res.
 En Modelica tienen lugar las siguientes afirmaciones:
\end_layout

\begin_layout Itemize
Lo que en lenguajes convencionales se define con asignaciones en general
 en Modelica se define con ecuaciones.
\end_layout

\begin_layout Itemize
La asignación de valores a atributos se representa como ecuaciones.
\end_layout

\begin_layout Itemize
Las conexiones entre objetos generan ecuaciones.
\end_layout

\begin_layout Standard
Las ecuaciones son más poderosas que las asignaciones.
 Por ejemplo, consideremos la ecuación característica de una resistencia:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
R\times i & =v
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
donde 
\begin_inset ERT
status open

\begin_layout Plain Layout

$R$
\end_layout

\end_inset

 es el valor de la resistencia.
\end_layout

\begin_layout Standard
Esta ecuación puede ser utilizada de tres maneras correspondientes a tres
 asignaciones posibles: calcular la corriente a partir del voltaje y de
 la resistencia, calcular el voltaje a partir de la resistencia y de la
 corriente o calcular la resistencia a partir del voltaje y de la corriente.
 A continuación vemos las tres posibles asignaciones:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
i & :=\frac{v}{R}\\
v & :=R\times i\\
R & :=\frac{v}{i}
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
Las ecuaciones en Modelica se pueden clasificar informalmente en cuatro
 grupos dependiendo en el contexto sintáctico en el que aparezcan:
\end_layout

\begin_layout Itemize
Ecuaciones normales, las cuales aparecen en la sección 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+equation+
\end_layout

\end_inset

.
\end_layout

\begin_layout Itemize
Ecuaciones que aparecen en la sección de declaraciones y forman parte de
 la declaración de una variable o constante.
\end_layout

\begin_layout Itemize
Ecuaciones como modificadores las cuales se utilizan para modificar atributos.
\end_layout

\begin_layout Itemize
Ecuación de inicialización las cuales se especifican en la sección 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+initial equation+
\end_layout

\end_inset

 o como para indicar el valor del atributo 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+start+
\end_layout

\end_inset

.
 Estas ecuaciones se utilizan para resolver el problema de inicialización
 al momento de inicio de la simulación.
\end_layout

\begin_layout Standard
Como ya hemos visto en los ejemplos anteriores las ecuaciones normales aparecen
 en las secciones delimitadas por la palabra clave 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+equation+
\end_layout

\end_inset

 y por alguna otra palabra clave permitida:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}[language=Modelica]
\end_layout

\begin_layout Plain Layout

	equation
\end_layout

\begin_layout Plain Layout

		...
\end_layout

\begin_layout Plain Layout

		<equations>
\end_layout

\begin_layout Plain Layout

		...
\end_layout

\begin_layout Plain Layout

	<some other allowed keyword> 
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
La ecuación de la resistencia que mostramos más arriba es un ejemplo de
 una ecuación que puede ser ubicada en una sección 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+equation+
\end_layout

\end_inset

.
 Las ecuaciones que aparecen en la sección de declaraciones generalmente
 se utilizan como parte de la declaración de constantes paramétricas o fijas,
 por ejemplo:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}[language=Modelica]
\end_layout

\begin_layout Plain Layout

	constant Integer one = 1;
\end_layout

\begin_layout Plain Layout

	parameter Real mass = 22.5; 
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
La veracidad de una ecuación se mantiene siempre, lo que significa que la
 masa en el ejemplo anterior nunca varia durante la simulación.
 También es posible especificar una ecuación en la declaración de una variable
 común, por ejemplo:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}[language=Modelica]
\end_layout

\begin_layout Plain Layout

	Real speed = 72.4; 
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Sin embargo esto no tiene mucho sentido ya que va a restringir la variable
 a que tenga el mismo valor durante toda la ejecución haciendo que se comporte
 como una constante.
 De esta manera se puede notar que la utilización de una ecuación en la
 declaración de una variable es bastante diferente de la inicialización
 de una variable en otros lenguajes.
\end_layout

\begin_layout Standard
Las asignaciones de valores a atributos se realizan utilizando ecuaciones
 como modificadores.
 Por ejemplo, si necesitamos especificar un valor inicial para una variable
 lo que hacemos es definir una ecuación para el atributo 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+start+
\end_layout

\end_inset

 de la variable:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}[language=Modelica]
\end_layout

\begin_layout Plain Layout

	Real speed(start=72.4); 
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Cabe destacar que la causalización se aplica sobre las ecuaciones normales,
 es decir las declaradas en las secciones 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+equation+
\end_layout

\end_inset

.
\end_layout

\begin_layout Subsubsection
Ecuaciones con Estructuras Repetitivas
\end_layout

\begin_layout Standard
A veces surge la necesidad de expresar convenientemente conjuntos de ecuaciones
 con estructuras que se repiten.
 Para estos casos Modelica ofrece un tipo particular de ecuación denominado
 loop equation.
 Notar que esto no es un bucle en el sentido algorítmico de la palabra sino
 que es una forma abreviada de expresar un conjunto de ecuaciones.
\end_layout

\begin_layout Standard
Por ejemplo, consideremos una ecuación para una expresión polinomial:
\end_layout

\begin_layout Standard
\begin_inset Formula $\begin{aligned}y & = & a[1]+a[2]\times x+a[3]\times x^{2}+\ldots+a[n+1]\times x^{n}\end{aligned}
$
\end_inset


\end_layout

\begin_layout Standard
La ecuación polinomial se puede expresar como un conjunto de ecuaciones
 con la misma estructura más una ecuación adicional donde 
\begin_inset ERT
status open

\begin_layout Plain Layout

$y$
\end_layout

\end_inset

 es igual al producto escalar de los vectores a y xpowers, ambos de longitud
 n+1:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}[language=Modelica]
\end_layout

\begin_layout Plain Layout

  xpowers[1] = 1;
\end_layout

\begin_layout Plain Layout

  xpowers[2] = xpowers[1]*x;
\end_layout

\begin_layout Plain Layout

  xpowers[3] = xpowers[2]*x;
\end_layout

\begin_layout Plain Layout

  ...
\end_layout

\begin_layout Plain Layout

  xpowers[n+1] = xpowers[n]*x;
\end_layout

\begin_layout Plain Layout

  y = a * xpowers;
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
El conjunto de ecuaciones sobre las variables 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+xpowers+
\end_layout

\end_inset

 se pueden expresar de manera más conveniente utilizando la notación 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+for+
\end_layout

\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}[language=Modelica]
\end_layout

\begin_layout Plain Layout

  for i in 1:n loop
\end_layout

\begin_layout Plain Layout

    xpowers[i+1] = xpowers[i]*x;
\end_layout

\begin_layout Plain Layout

  end for;
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Manipulación simbólica de modelos Modelica
\end_layout

\begin_layout Standard
Vamos a comenzar la sección detallando brevemente los pasos necesarios para
 traducir y simular un modelo Modelica.
 Luego profundizaremos en las técnicas de manipulación simbólica utilizadas
 para convertir los modelos DAE en modelos ODE ordenados.
\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "sec:Implementación-y-ejecución"

\end_inset

Compilación y Simulación de modelos Modelica
\end_layout

\begin_layout Standard
El primer paso del proceso de compilación consisten en un análisis sintáctico
 del código fuente Modelica del cual se obtiene un árbol sintáctico abstracto.
 Luego esta representación se analiza gramaticalmente, se realiza la verificació
n de tipos, las clases se heredan y expanden, se realizan las modificaciones
 e instanciaciones correspondientes, las ecuaciones 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+connect+
\end_layout

\end_inset

 se convierten en ecuaciones comunes, etc.
 El resultado de este proceso de análisis y traducción es un conjunto plano
 de ecuaciones, constantes, variables y funciones.
 No queda ningún rastro de la estructura de objetos.
\end_layout

\begin_layout Standard
Después del proceso de aplanado todas las ecuaciones se ordenan topológicamente
 de acuerdo a las dependencias del flujo de datos entre ellas.
 En el caso de ecuaciones diferenciales algebraicas, no solo se realiza
 un ordenamiento, sino que también es necesario manipular las ecuaciones
 para convertir la matriz de coeficientes a forma triangular inferior de
 a bloques, lo que usualmente se denomina transformación BLT por sus siglas
 en ingles 
\begin_inset CommandInset citation
LatexCommand citep
key "Fritzson98"

\end_inset

.
 Luego un módulo de optimización compuesto por algoritmos de simplificación
 algebraica, métodos de reducción de índices, etc., elimina la mayoría de
 las ecuaciones dejando solo un conjunto mínimo que eventualmente va a ser
 resuelto numéricamente.
 Por ejemplo, si dos variables son sintácticamente equivalentes solo se
 conserva una.
\end_layout

\begin_layout Standard
La etapa siguiente consiste en convertir las ecuaciones independientes resultant
es en asignaciones.
 Esto es posible dado que las ecuaciones fueron ordenadas y se determinó
 una secuencia de ejecución para la evaluación de las ecuaciones.
 Si aparece un conjunto de ecuaciones fuertemente conectadas (un bucle algebraic
o) se realizan transformaciones simbólicas que ejecutan una serie de transformac
iones algebraicas para simplificar las dependencias entre las variables.
 En ciertos casos se puede resolver el sistema de ecuaciones que representa
 el lazo si este posee solución simbólica.
\end_layout

\begin_layout Standard
Finalmente se genera código en algún lenguaje de programación convencional,
 usualmente C, y se lo enlaza con algún método de integración numérica el
 cual es el encargado de resolver el sistema de ecuaciones resultante, sistema
 que ya a sido drásticamente reducido.
\end_layout

\begin_layout Standard
En la figura 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:compilacion_Modelica}
\end_layout

\end_inset

 se pueden ver las distintas etapas del proceso de traducción y ejecución.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{figure}[H]
\end_layout

\begin_layout Plain Layout

  
\backslash
centering
\end_layout

\begin_layout Plain Layout

  
\backslash
includegraphics[width=0.3
\backslash
textwidth]{graphics/EtapasCompilacion.jpg}
\end_layout

\begin_layout Plain Layout

  
\backslash
caption{Etapas del proceso de compilación y ejecución de Modelica.}
\end_layout

\begin_layout Plain Layout

  
\backslash
label{fig:compilacion_Modelica}
\end_layout

\begin_layout Plain Layout


\backslash
end{figure}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Simplificación Simbólica de Modelos Modelica
\end_layout

\begin_layout Standard
Como mencionamos previamente luego del proceso de aplanado de la estructura
 de objetos lo que se obtiene es un sistema de ecuaciones diferenciales
 algebraicas.
 Simular un modelo Modelica en general consiste en resolver sistemas de
 ese tipo.
 Esta tarea no es trivial por varias razones:
\end_layout

\begin_layout Itemize
Las ecuaciones no solo poseen incógnitas de tipo 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+Real+
\end_layout

\end_inset

 sino también 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+Boolean+
\end_layout

\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+Integer+
\end_layout

\end_inset

 y 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+enumeration+
\end_layout

\end_inset

.
\end_layout

\begin_layout Itemize
La naturaleza orientada a objetos de los modelos Modelica, los cuales usualmente
 consisten de muchos componentes conectados, resulta después del aplanado
 en sistemas DAE bastante ralos (una matriz asociada con muchos ceros) 
\begin_inset CommandInset citation
LatexCommand citep
key "elmqvist2005"

\end_inset

.
\end_layout

\begin_layout Itemize
Las orientación a objetos da lugar a que los usuarios escriban modelos muy
 grandes, incluso modelos con varias cientos de miles de ecuaciones y variables.
 Modelos tan grandes plantean demandas especiales sobre las técnicas de
 solución.
\end_layout

\begin_layout Standard
Muchas de estas dificultades pueden ser resueltas manipulando simbólicamente
 el sistema de ecuaciones antes de aplicar un método de integración numérico.
 En la sección 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Implementación-y-ejecución"

\end_inset

 mencionamos el método de realizar una partición BLT, o ordenamiento topológico,
 del sistema de ecuaciones utilizando el algoritmo de Tarjan 
\begin_inset CommandInset citation
LatexCommand citep
key "Tarjan72"

\end_inset

.
 Este algoritmo encuentra los componentes fuertemente conexos conteniendo
 ecuaciones mutuamente dependientes, i.e bucles algebraicos.
 El particionado del sistema de ecuaciones posibilita una solución más eficiente
 reduciendo la cantidad de variables que tienen que ser manejadas por el
 método de integración en cada subsistema de ecuaciones.
 
\end_layout

\begin_layout Standard
Algunos de los subsistemas de ecuaciones simultaneas encontrados por el
 particionado BLT son lineales y pueden ser resueltos por algoritmos de
 álgebra estándar de sistemas de ecuaciones lineales.
 Otros sistemas resultan ser no lineales.
 Una técnica denominada 
\shape italic
tearing
\shape default
 puede reducir aún más el tamaño y contribuir a mejorar la eficiencia cuando
 se resuelven este tipo de sistemas de ecuaciones no lineales 
\begin_inset CommandInset citation
LatexCommand citep
key "CK06"

\end_inset

.
 La técnica de tearing permite resolver de manera secuencial pero iterativamente
 las ecuaciones de un subsistema eligiendo en cada iteración la 
\begin_inset Quotes eld
\end_inset

tearing variable
\begin_inset Quotes erd
\end_inset

 y comenzando con un primera aproximación del valor de la variable.
 La convergencia de este proceso no está garantida, sin embargo en la mayoría
 de los casos ocurre.
\end_layout

\begin_layout Standard
La necesidad de diferenciar numéricamente utilizando métodos de integración
 númericos de DAEs puede ser reducida o eliminada empleando el algoritmo
 de Pantelides para la 
\shape italic
reducción de índice 
\shape default
el cual transforma simbólicamente el sistema de ecuaciones a una forma de
 menor índice.
 El sistema de ecuaciones resultantes con índice no mayor a 1 puede ser
 resuelto por algoritmos de integración numérica como DASSL 
\begin_inset CommandInset citation
LatexCommand citep
key "DASSL"

\end_inset

 o DOPRI 
\begin_inset CommandInset citation
LatexCommand citep
key "DP80"

\end_inset

 y incluso en algunos casos utilizando simples métodos de resolución de
 ODEs como Euler 
\begin_inset CommandInset citation
LatexCommand citep
key "CK06"

\end_inset

.
\end_layout

\begin_layout Standard
Descripciones de la técnica de tearing y del algoritmo de Pantelides se
 pueden encontrar en los siguientes libros 
\begin_inset CommandInset citation
LatexCommand citep
key "Fritzson:2003:POM:966262,CK06"

\end_inset

.
 En la sección siguiente vamos a explicar en qué consiste la transformación
 o particionado BLT del sistema de ecuaciones también denominado proceso
 de causalización de ecuaciones.
\end_layout

\begin_layout Section
\begin_inset CommandInset label
LatexCommand label
name "sub:Transformación-BLT--"

\end_inset

Causalización - Transformación BLT
\end_layout

\begin_layout Standard
Los sistemas de ecuaciones diferenciales algebraicas resultantes de aplanar
 la estructura de objetos de un modelo Modelica por lo general son grandes,
 ralos (una matriz de incidencia asociada con muchos ceros) y no lineales
 
\begin_inset CommandInset citation
LatexCommand citep
key "elmqvist2005"

\end_inset

.
\end_layout

\begin_layout Standard
Permutando las ecuaciones y las variables es posible transformar el sistema
 de ecuaciones, o mejor dicho la matriz asociada, a una forma triangular
 inferior de a bloques (o BLT por sus siglas en inglés).
 Una vez llevado a esta forma BLT el sistema puede ser resuelto secuencialmente.
 Vamos a explicar la idea utilizando un ejemplo simple el cual consiste
 de 3 ecuaciones no lineales.
\begin_inset Formula 
\begin{gather}
h_{1}(z_{1},z_{3})=0\nonumber \\
h_{2}(z_{2})=0\nonumber \\
h_{3}(z_{1},z_{2})=0\label{eq:ej_transformacion_blt_sis}
\end{gather}

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{gather}
S_{1}=\begin{array}{c}
\begin{array}{ccc}
z_{1} & z_{2} & z_{3}\end{array}\\
\left[\begin{array}{ccc}
1 & 0 & 1\\
0 & 1 & 0\\
1 & 1 & 0
\end{array}\right]
\end{array}\label{eq:ej_transformacion_blt_matriz}
\end{gather}

\end_inset


\end_layout

\begin_layout Standard
La matriz 
\begin_inset Formula $S_{1}$
\end_inset

describe la estructura del sistema de ecuaciones.
 La entrada S
\begin_inset Formula $_{ij}$
\end_inset

 es 1 si la variable i aparece en la ecuación j y 0 en caso contrario.
 Permutando las ecuaciones y las variables este conjunto de ecuaciones puede
 ser llevado a la forma BLT:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{gather}
h_{2}(z_{2})=0\nonumber \\
h_{3}(z_{1},z_{2})=0\label{eq:ej_transformacion_blt_sis_2}\\
h_{1}(z_{1},z_{3})=0\nonumber 
\end{gather}

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{gather}
S_{2}=\begin{array}{c}
\begin{array}{ccc}
z_{2} & z_{1} & z_{3}\end{array}\\
\left[\begin{array}{ccc}
1 & 0 & 0\\
1 & 1 & 0\\
0 & 1 & 1
\end{array}\right]
\end{array}\label{eq:ej_tranformacion_blt_matriz_2}
\end{gather}

\end_inset


\end_layout

\begin_layout Standard
Este proceso se denomina particionado del conjunto de ecuaciones.
 La forma triangular inferior estricta de la matriz asociada al sistema
 permite ver el hecho de que las ecuaciones no lineales pueden ser resueltas
 una por vez de manera secuencial.
 Comenzamos resolviendo 
\begin_inset Formula $h_{2}$
\end_inset

 para la variable 
\begin_inset Formula $z_{2}$
\end_inset

, luego, conociendo 
\begin_inset Formula $z_{2}$
\end_inset

 podemos resolver 
\begin_inset Formula $h3$
\end_inset

 para 
\begin_inset Formula $z_{1}$
\end_inset

 y finalmente podemos determinar 
\begin_inset Formula $z_{3}$
\end_inset

 a partir de 
\begin_inset Formula $h_{1}$
\end_inset

 ya conociendo 
\begin_inset Formula $z_{2}$
\end_inset

 y 
\begin_inset Formula $z_{1}$
\end_inset

.
 Si la variable a resolver aparece linealmente en una ecuación, la variable
 puede ser despejada mediante manipulación simbólica.
 En caso contrario se requiere una iteración local de Newton.
\end_layout

\begin_layout Standard
En general no es posible transformar la matriz asociada a la forma triangular
 inferior estricta.
 Sin embargo existen algoritmos eficientes para convertir la matriz a una
 forma triangular inferior de a bloques, esto es una forma cuasi-triangular
 inferior en donde a lo largo de la diagonal aparecen bloques de dimensión
 
\begin_inset Formula $\geqq1$
\end_inset

.
 Un ejemplo de matriz triangular inferior de a bloques se puede ver en la
 figura 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:post_Tarjan}
\end_layout

\end_inset

 de la sección 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Aplicacion-Tarjan-Marco-Teorico"

\end_inset

.
 Esta no es una matriz triangular inferior estricta ya que la celda (
\begin_inset Formula $f{}_{3}$
\end_inset

, 
\begin_inset Formula $z{}_{5}$
\end_inset

), la cual posee un valor distinto de cero, se encuentra por encima de la
 diagonal.
 No obstante, dicha celda pertece a una submatriz o bloque de 
\begin_inset Formula $2\times2$
\end_inset

.
 Entonces considerando al resto de los elementos de la diagonal como bloques
 de 
\begin_inset Formula $1\times1$
\end_inset

 podemos decir que la matriz es triangular inferior de a bloques.
\end_layout

\begin_layout Standard
Los algoritmos que permiten transformar una matriz en la forma BLT garantizan
 que las dimensiones de los bloques son del menor tamaño posible.
 Es decir no se pueden obtener bloques más pequeños mediante la permutación
 de variables y ecuaciones.
 Los bloques de tamaño 
\begin_inset Formula $>1$
\end_inset

 corresponden a sistemas de ecuaciones que tienen que ser resueltos simultáneame
nte.
 A estos sub-sistemas de ecuaciones mutuamente dependientes se los denomina
 lazos algebraicos.
 Finalmente podemos concluir que los algoritmos de particionado encuentra
 lazos algebraicos de dimensiones mínimas.
\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "sub:Algoritmos-de-grafos"

\end_inset

Algoritmos de grafos para obtener la transformación BLT
\end_layout

\begin_layout Standard
En el artículo 
\begin_inset CommandInset citation
LatexCommand citep
key "Duff:1978:ITA:355780.355785"

\end_inset

 se demuestra que la forma más eficiente de calcular la transformación BLT
 de una matriz es aplicando el algoritmo de Tarjan 
\begin_inset CommandInset citation
LatexCommand citep
key "Tarjan72"

\end_inset

.
 Este es un algoritmo perteneciente a la teoría de grafos, el cual permite
 encontrar los componentes fuertemente conexos en un grafo dirigido.
\end_layout

\begin_layout Standard
Dada una matriz 
\begin_inset Formula $S$
\end_inset

, para poder aplicar el algoritmo de Tarjan y obtener una transformación
 BLT, es necesario construir un grafo dirigido compuesto por un conjunto
 de n nodos, etiquetados 
\begin_inset Formula $1,2,3,\ldots,n$
\end_inset

 y un conjunto de aristas 
\begin_inset Formula $(i,j)$
\end_inset

 cada una de las cuales es un par ordenado de nodos correspondiente a una
 entrada 
\begin_inset Formula $S_{ij}$
\end_inset

 distinta de cero y ubicada fuera de la diagonal.
 Realizar una permutación de la matriz 
\begin_inset Formula $S$
\end_inset

 se corresponde con re-etiquetar los nodos del grafo.
\end_layout

\begin_layout Standard
Se dice que un subgrafo es fuertemente conexo si existe un camino desde
 cualquiera de sus nodos hacia cualquier otro nodo y que es un componente
 fuertemente conexo si no puede ser agrandado a otro subgrafo fuertemente
 conexo agregando nodos y las aristas asociadas.
 Claramente, cada nodo puede pertenecer solo a un componente fuertemente
 conexo (que puede componerse de un solo nodo) por lo tanto los componentes
 fuertemente conexos determinan una partición del grafo.
 Debe haber al menos un componente fuertemente conexo tal que no exista
 camino de ninguno de sus nodos hacia algún nodo de otro componente.
 Denominemos 
\begin_inset Formula $C_{1}$
\end_inset

a este componente.
 Los otros componentes fuertemente conexos 
\begin_inset Formula $C_{2},C_{3},\ldots,C_{k}$
\end_inset

 pueden ser elegidos aplicando el mismo criterio de manera tal que no exista
 ningún camino de un nodo en un componente fuertemente conexo hacia un nodo
 de un componente fuertemente conexo que aparezca después en la secuencia.
\end_layout

\begin_layout Standard
Si estos componentes fuertemente conexos son identificados en el orden mostrado
 en el párrafo anterior, y los nodos de 
\begin_inset Formula $C_{1}$
\end_inset

son numerados antes de los nodos de 
\begin_inset Formula $C_{2}$
\end_inset

, y así sucesivamente, entonces la matriz asociada es triangular de a bloques
 donde los bloques se corresponden con los componentes fuertemente conexos
 del grafo.
 Además, dado que el subgrafo asociado con cada submatriz de la diagonal
 en la forma de a bloques es fuertemente conexo, es evidente que los bloques
 no pueden ser permutados a la forma BLT.
\end_layout

\begin_layout Standard
En el artículo
\begin_inset CommandInset citation
LatexCommand citep
key "Duff:1978:ITA:355780.355785"

\end_inset

 Duff presenta dos algoritmos que exhiben esta propiedad en donde los componente
s fuertemente conexos son identificados en un orden tal que los nodos de
 cada componente pueden poseer caminos que conducen a nodos de componentes
 previos pero nunca a nodos de componentes posteriores.
 Estos algoritmos son el de Sargent and Westerber 
\begin_inset CommandInset citation
LatexCommand citep
key "sargent1964speed"

\end_inset

 y el de Tarjan.
 Mientras el algoritmo de Sargent and Westerber presenta una complejidad
 temporal (en función de la cantidad de variables) en el peor caso de 
\begin_inset Formula $O(n^{2})$
\end_inset

 el algoritmo de Tarjan se ejecuta en 
\begin_inset Formula $O(n)+O(\tau)$
\end_inset

 donde 
\begin_inset Formula $\tau$
\end_inset

 es la cantidad de entradas de la matriz que no pertenecen a la diagonal
 y son diferentes de 0.
\end_layout

\begin_layout Subsection
Algoritmo de Tarjan para encontrar los componentes fuertemente conexos de
 un grafo
\end_layout

\begin_layout Standard
El algoritmo de Tarjan recibe como entrada un grafo dirigido y produce una
 partición de los vértices del grafo en componentes fuertemente conexos.
 Cada vértice del grafo aparece en un solo componente fuertemente conexo.
 Un vértice que no pertenece a ningún ciclo constituye por si solo un componente
 fuertemente conexo.
\end_layout

\begin_layout Standard
La idea básica del algoritmo es la siguiente: comenzando por cualquier nodo
 se realiza una búsqueda en profundidad (y subsiguientes búsquedas se realizan
 sobre cualquier nodo que no haya sido visitado aún).
 Como es usual en las búsquedas en profundidad, el proceso de búsqueda visita
 cada nodo una sola vez y rechaza visitar un nodo que ya fue explorado.
 En consecuencia la colección de árboles de búsqueda es un bosque recubridor
 del grafo.
 Los componentes fuertemente conexos se van a obtener a partir de algunos
 subárboles del bosque recubridor.
 Las raíces de estos árboles serán las raíces de los componentes fuertemente
 conexos.
 Cualquier nodo de un componente fuertemente conexo puede ser el nodo raíz
 siempre y cuando haya sido el primer nodo en ser descubierto para ese component
e.
\end_layout

\begin_layout Standard
Los nodos se van almacenando en una pila en el orden en el que se van encontrand
o.
 Cuando el proceso de búsqueda en profundidad recursivamente explora un
 nodo v y sus descendientes, dichos nodos no necesariamente son retirados
 (popped) de la pila antes de que la llamada recursiva termine.
 La propiedad invariante fundamental es que un nodo permanece en la pila
 después de ser explorado si y solo si posee un camino (path) hacia un nodo
 ingresado previamente en la pila.
\end_layout

\begin_layout Standard
Al final de la llamada que explora el nodo v y sus descendientes sabemos
 si este posee algún camino hacia un nodo ingresado previamente en la pila.
 De ser así la llamada retorna dejando el vértice v en la pila para preservar
 el invariante.
 En caso contrario v debe ser la raíz de su componente fuertemente conexo
 el cual consiste en v más cualquier nodo colocado posteriormente.
 El componente identificado se retira de la pila.
\end_layout

\begin_layout Standard
A cada nodo v se le asigna un entero único 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+v.index+
\end_layout

\end_inset

 el cual numera los nodos de manera consecutiva en el orden en el que son
 descubiertos.
 Además para cada nodo también se mantiene un valor denominado 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+v.lowlink+
\end_layout

\end_inset

 el cual representa el menor índice asociado a un nodo accesible desde v,
 incluido el mismo v.
 De esta manera v debe ser mantenido en la pila si 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+v.lowlink < v.index+
\end_layout

\end_inset

, y v debe ser removido de la pila si 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+v.lowlink == v.index+
\end_layout

\end_inset

.
 El valor 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+v.lowlink+
\end_layout

\end_inset

 es calculado durante la búsqueda en profundidad originada en v.
 
\end_layout

\begin_layout Standard
A continuación vemos el algoritmo en pseudo-código:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}
\end_layout

\begin_layout Plain Layout

algorithm Tarjan is
\end_layout

\begin_layout Plain Layout

  input: graph G = (V, E)
\end_layout

\begin_layout Plain Layout

  output: set of strongly connected components (sets of vertices) 
\end_layout

\begin_layout Plain Layout

 
\end_layout

\begin_layout Plain Layout

  index := 0 
\end_layout

\begin_layout Plain Layout

  S := empty
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  for each v in V do
\end_layout

\begin_layout Plain Layout

    if (v.index is undefined) then
\end_layout

\begin_layout Plain Layout

      strongconnect(v)
\end_layout

\begin_layout Plain Layout

    end if
\end_layout

\begin_layout Plain Layout

  end for
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  function strongconnect(v)
\end_layout

\begin_layout Plain Layout

    // Set the depth index for v to the smallest unused index
\end_layout

\begin_layout Plain Layout

    v.index := index
\end_layout

\begin_layout Plain Layout

    v.lowlink := index
\end_layout

\begin_layout Plain Layout

    index := index + 1
\end_layout

\begin_layout Plain Layout

    S.push(v)
\end_layout

\begin_layout Plain Layout

    v.onStack := true
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    // Consider successors of v
\end_layout

\begin_layout Plain Layout

    for each (v, w) in E do
\end_layout

\begin_layout Plain Layout

      if (w.index is undefined) then
\end_layout

\begin_layout Plain Layout

        // Successor w has not yet been visited;
\end_layout

\begin_layout Plain Layout

        strongconnect(w)
\end_layout

\begin_layout Plain Layout

        v.lowlink  := min(v.lowlink, w.lowlink)
\end_layout

\begin_layout Plain Layout

      else if (w.onStack) then
\end_layout

\begin_layout Plain Layout

        // Successor w is in stack S and hence in the current SCC
\end_layout

\begin_layout Plain Layout

        v.lowlink  := min(v.lowlink, w.index)
\end_layout

\begin_layout Plain Layout

      end if
\end_layout

\begin_layout Plain Layout

    end for
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

    // If v is a root node, pop the stack and generate an SCC
\end_layout

\begin_layout Plain Layout

    if (v.lowlink = v.index) then
\end_layout

\begin_layout Plain Layout

      start a new strongly connected component
\end_layout

\begin_layout Plain Layout

      repeat
\end_layout

\begin_layout Plain Layout

        w := S.pop()
\end_layout

\begin_layout Plain Layout

        w.onStack := false
\end_layout

\begin_layout Plain Layout

        add w to current strongly connected component
\end_layout

\begin_layout Plain Layout

      while (w != v)
\end_layout

\begin_layout Plain Layout

      output the current strongly connected component
\end_layout

\begin_layout Plain Layout

    end if
\end_layout

\begin_layout Plain Layout

  end function
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Vamos a finalizar la sección aplicando el algoritmo sobre el grafo de la
 figura 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:tarjan_step_0}
\end_layout

\end_inset

.
 Entre las figuras 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:tarjan_step_1}
\end_layout

\end_inset

 y 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:tarjan_step_4}
\end_layout

\end_inset

 se puede ver la evolución del algoritmo.
 En cada una de las figuras se destaco con linea de trazo continuo el camino
 que condujo a la identificación de un componente fuertemente conexo.
 Junto a cada nodo se incluyo el valor de las variables 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+index+
\end_layout

\end_inset

 y 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+lowlink+
\end_layout

\end_inset

.
 También se incluyo junto a cada figura el estado de la pila en el momento
 previo a la identificación del componente.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{figure}[H]
\end_layout

\begin_layout Plain Layout

    
\backslash
begin{subfigure}[b]{0.3
\backslash
textwidth}
\end_layout

\begin_layout Plain Layout

    
\backslash
includegraphics[width=0.8
\backslash
textwidth]{graphics/revision/tarjan_step_0.png}
\end_layout

\begin_layout Plain Layout

    
\backslash
caption{
\backslash
label{fig:tarjan_step_0}}
\end_layout

\begin_layout Plain Layout

  
\backslash
end{subfigure}
\end_layout

\begin_layout Plain Layout

  
\backslash
begin{subfigure}[b]{0.3
\backslash
textwidth}
\end_layout

\begin_layout Plain Layout

    
\backslash
includegraphics[width=0.8
\backslash
textwidth]{graphics/revision/tarjan_step_1.png}
\end_layout

\begin_layout Plain Layout

    
\backslash
caption{
\backslash
label{fig:tarjan_step_1}}
\end_layout

\begin_layout Plain Layout

  
\backslash
end{subfigure}
\end_layout

\begin_layout Plain Layout

  
\backslash
begin{subfigure}[b]{0.3
\backslash
textwidth}
\end_layout

\begin_layout Plain Layout

    
\backslash
includegraphics[width=0.8
\backslash
textwidth]{graphics/revision/tarjan_step_2.png}
\end_layout

\begin_layout Plain Layout

    
\backslash
caption{
\backslash
label{fig:tarjan_step_2}}
\end_layout

\begin_layout Plain Layout

  
\backslash
end{subfigure}
\end_layout

\begin_layout Plain Layout

  
\backslash
begin{subfigure}[b]{0.3
\backslash
textwidth}
\end_layout

\begin_layout Plain Layout

    
\backslash
includegraphics[width=0.8
\backslash
textwidth]{graphics/revision/tarjan_step_3.png}
\end_layout

\begin_layout Plain Layout

    
\backslash
caption{
\backslash
label{fig:tarjan_step_3}}
\end_layout

\begin_layout Plain Layout

  
\backslash
end{subfigure}
\end_layout

\begin_layout Plain Layout

  
\backslash
begin{subfigure}[b]{0.3
\backslash
textwidth}
\end_layout

\begin_layout Plain Layout

    
\backslash
includegraphics[width=0.8
\backslash
textwidth]{graphics/revision/tarjan_step_4.png}
\end_layout

\begin_layout Plain Layout

    
\backslash
caption{
\backslash
label{fig:tarjan_step_4}}
\end_layout

\begin_layout Plain Layout

  
\backslash
end{subfigure}
\end_layout

\begin_layout Plain Layout

  
\backslash
caption{
\backslash
label{fig:tarjan_step_by_step}}
\end_layout

\begin_layout Plain Layout


\backslash
end{figure}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "sub:Aplicacion-Tarjan-Marco-Teorico"

\end_inset

Aplicación del algoritmo de Tarjan para obtener la forma BLT
\end_layout

\begin_layout Standard
En esta sección vamos explicar cómo aplica el algorítmo de Tarjan en la
 transformación a la forma triangular inferior de a bloques de la matriz
 asociada a un sistema de ecuaciones algebraicas.
\end_layout

\begin_layout Standard
Para explicar el algoritmo vamos a utilizar el sistema de ecuaciones diferencial
es algebraicas que aparece en la figura 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:pre_Tarjan}
\end_layout

\end_inset

 junto con su matriz de coeficientes asociada.
 La matriz de coeficientes posee una fila por cada ecuación y una columna
 por cada incógnita.
 Una entrada (i,j) de la matriz toma el valor 1 si la variable j ocurre
 en la ecuación i.
 En caso contrario la entrada de la matriz es 0.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{figure}[H]
\end_layout

\begin_layout Plain Layout

  
\backslash
centering
\end_layout

\begin_layout Plain Layout

  
\backslash
begin{align*}
\end_layout

\begin_layout Plain Layout

    f_1(z_3,z_4) &= 0 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

    f_2(z_2) &= 0 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

    f_3(z_2,z_3,z_5) &= 0 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

    f_4(z_1,z_2) &= 0 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

    f_5(z_1,z_3,z_5) &= 0 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

  
\backslash
end{align*}
\end_layout

\begin_layout Plain Layout

  
\backslash
bordermatrix{
\end_layout

\begin_layout Plain Layout

       & z_1 & z_2 & z_3 & z_4 & z_5 
\backslash
cr
\end_layout

\begin_layout Plain Layout

   f_1 & 0   & 0   & 1   & 1   & 0 
\backslash
cr
\end_layout

\begin_layout Plain Layout

   f_2 & 0   & 1   & 0   & 0   & 0 
\backslash
cr
\end_layout

\begin_layout Plain Layout

   f_3 & 0   & 1   & 1   & 0   & 1 
\backslash
cr
\end_layout

\begin_layout Plain Layout

   f_4 & 1   & 1   & 0   & 0   & 0 
\backslash
cr
\end_layout

\begin_layout Plain Layout

   f_5 & 1   & 0   & 1   & 0   & 1 
\backslash
cr
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  
\backslash
caption{Sistema de ecuaciones junto con la matriz de adjacencia asociada.
\backslash
label{fig:pre_Tarjan}}
\end_layout

\begin_layout Plain Layout


\backslash
end{figure}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Tal como explicamos en la sección 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Algoritmos-de-grafos"

\end_inset

, para poder obtener la transformación BLT de una matriz, necesitamos construir
 un grafo dirigido a partir de la misma y aplicar el algoritmo de Tarjan
 sobre ese grafo.
 En el caso de la matriz de coeficientes asociada a un sistema de ecuaciones
 diferenciales el grafo que se obtiene es un grafo bipartito no dirigido.
 Por lo tanto es necesario generar a partir de este un grafo dirigido sobre
 el cual poder aplicar el algoritmo de Tarjan.
 En la figura 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:grafo_pre_Tarjan}
\end_layout

\end_inset

 se puede ver el grafo bipartito asociado a la matriz de coeficientes del
 ejemplo.
\end_layout

\begin_layout Standard
Notar que en la figura 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:grafo_pre_Tarjan}
\end_layout

\end_inset

 hemos destacada un conjunto de vértices y algunas de sus aristas adjacentes.
 Estos vértices forman un componente fuertemente conexo.
 Dicho componente se corresponde con un lazo algebraico del sistema de ecuacione
s compuesto por las ecuaciones 
\begin_inset Formula $f_{3}$
\end_inset

 y 
\begin_inset Formula $f_{5}$
\end_inset

.
 Más adelante, en la figura 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:system_post_Tarjan}
\end_layout

\end_inset

 se puede ver como, después de aplicar el algoritmo de Tarjan, el lazo algebraic
o formado por las ecuaciones 
\begin_inset Formula $f_{3}$
\end_inset

 y 
\begin_inset Formula $f_{5}$
\end_inset

 queda correctamente ordenado después de las ecuaciones 
\begin_inset Formula $f_{2}$
\end_inset

 y 
\begin_inset Formula $f_{4}$
\end_inset

 de la cuales depende.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{figure}[H]
\end_layout

\begin_layout Plain Layout

   
\backslash
centering
\end_layout

\begin_layout Plain Layout

   
\backslash
includegraphics[width=0.3
\backslash
textwidth]{graphics/revision/bipartito_original.png}
\end_layout

\begin_layout Plain Layout

   
\backslash
caption{Grafo bipartito correspondiente a la forma inicial del sistema de
 eucaciones.}
\end_layout

\begin_layout Plain Layout

   
\backslash
label{fig:grafo_pre_Tarjan}
\end_layout

\begin_layout Plain Layout


\backslash
end{figure}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
A partir del grafo bipartito se puede construir el grafo dirigido siguiendo
 los pasos que describimos a continuación.
\end_layout

\begin_layout Enumerate
Calculamos un emparejamiento
\begin_inset Foot
status open

\begin_layout Plain Layout
Del termino ingles 
\begin_inset Quotes eld
\end_inset

matching
\begin_inset Quotes erd
\end_inset

.
\end_layout

\end_inset

 máximo sobre el grafo original.
\end_layout

\begin_layout Enumerate
Para cada 
\begin_inset Formula $v{}_{e}$
\end_inset

 perteneciente al conjunto de vértices del grafo original asociados a ecuaciones
 creamos un vértice 
\begin_inset Formula $v_{e}^{d}$
\end_inset

 en el nuevo grafo dirigido.
\end_layout

\begin_layout Enumerate
Para cada par de aristas del grafo original (
\begin_inset Formula $v{}_{e1}$
\end_inset

, 
\begin_inset Formula $v{}_{i}$
\end_inset

) y (
\begin_inset Formula $v{}_{e2}$
\end_inset

, 
\begin_inset Formula $v{}_{i}$
\end_inset

), dentro y fuera del emparejamiento respectivamente, trazamos una arista
 en el grafo dirigido.
 Esta arista tendra como vértice de origen a 
\begin_inset Formula $v{}_{e2}^{d}$
\end_inset

 y como vértice destino a 
\begin_inset Formula $v{}_{e1}^{d}$
\end_inset

.
\end_layout

\begin_layout Standard
En la figura 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:matching}
\end_layout

\end_inset

 se puede ver el matching para el grafo bipartito 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:grafo_pre_Tarjan}
\end_layout

\end_inset

.
 El grafo dirigido, resultante de aplicar los pasos 2 y 3, se puede ver
 en la figura 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:colapsado}
\end_layout

\end_inset

.
 Finalmente en la figura 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:strong_components}
\end_layout

\end_inset

 se pueden ver los componentes fuertemente conexos en los que fue particionado
 el grafo luego de la aplicación del algoritmo de Tarjan.
 En la figura también se aprecia el orden en el que se identificaron los
 componentes.
 El detalle del proceso de identificación de cada uno de los componentes
 fuertemente conexos se puede ver en la figura 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:tarjan_step_by_step}
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{figure}[H]
\end_layout

\begin_layout Plain Layout

  
\backslash
centering
\end_layout

\begin_layout Plain Layout

  
\backslash
begin{subfigure}[b]{0.3
\backslash
textwidth}
\end_layout

\begin_layout Plain Layout

    
\backslash
includegraphics[width=0.8
\backslash
textwidth]{graphics/revision/bipartito_matching.png}
\end_layout

\begin_layout Plain Layout

    
\backslash
caption{
\backslash
label{fig:matching}}
\end_layout

\begin_layout Plain Layout

  
\backslash
end{subfigure}
\end_layout

\begin_layout Plain Layout

  
\backslash
begin{subfigure}[b]{0.3
\backslash
textwidth}
\end_layout

\begin_layout Plain Layout

    
\backslash
centering
\end_layout

\begin_layout Plain Layout

    
\backslash
includegraphics[width=1
\backslash
textwidth]{graphics/revision/dirigido.png}
\end_layout

\begin_layout Plain Layout

    
\backslash
caption{
\backslash
label{fig:colapsado}}
\end_layout

\begin_layout Plain Layout

  
\backslash
end{subfigure}
\end_layout

\begin_layout Plain Layout

  
\backslash
begin{subfigure}[b]{0.4
\backslash
textwidth}
\end_layout

\begin_layout Plain Layout

    
\backslash
centering
\end_layout

\begin_layout Plain Layout

    
\backslash
includegraphics[width=1
\backslash
textwidth]{graphics/revision/dirigido_componentes.png}
\end_layout

\begin_layout Plain Layout

    
\backslash
caption{
\backslash
label{fig:strong_components}}
\end_layout

\begin_layout Plain Layout

  
\backslash
end{subfigure}
\end_layout

\begin_layout Plain Layout


\backslash
caption{Aplicación del algoritmo de Tarjan
\backslash
label{fig:aplicacion_tarjan}}
\end_layout

\begin_layout Plain Layout


\backslash
end{figure}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
A partir del orden de los componentes fuertemente conexos que arroja el
 algoritmo de Tarjan podemos reordenar las columnas y filas de la matriz
 de coeficientes del sistema de ecuaciones.
 Es decir la fila correspondiente a la ecuación 
\begin_inset Formula $f{}_{2}$
\end_inset

 y la columna correspondiente a la variable 
\begin_inset Formula $z{}_{2}$
\end_inset

 se ubican en la primer posición, luego la fila correspondiente a 
\begin_inset Formula $f{}_{4}$
\end_inset

 y la columna correspondiente a 
\begin_inset Formula $z{}_{1}$
\end_inset

 ocupan la segunda posición y así sucesivamente.
 La figura 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:matrix_post_Tarjan}
\end_layout

\end_inset

 muestra la matriz de coeficientes resultante, la cual ha sido transformada
 a la forma triangular inferior de a bloques.
 El lazo algebraico destacado en la figura 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:grafo_pre_Tarjan}
\end_layout

\end_inset

 constituye un bloque de tamaño 2 en la diagonal de la matriz de coeficientes.
 El sistema de ecuaciones ordenado a partir del orden de los componentes
 fuertemente conexos determinado por el algoritmo de Tarjan, se puede ver
 en la figura 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:system_post_Tarjan}
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{figure}[H]
\end_layout

\begin_layout Plain Layout

  
\backslash
centering
\end_layout

\begin_layout Plain Layout

  
\backslash
hspace*{
\backslash
fill} 
\end_layout

\begin_layout Plain Layout

  
\backslash
begin{subfigure}[b]{0.3
\backslash
textwidth}
\end_layout

\begin_layout Plain Layout

  
\backslash
bordermatrix{
\end_layout

\begin_layout Plain Layout

       & z_2 & z_1 & z_3 & z_5 & z_4 
\backslash
cr
\end_layout

\begin_layout Plain Layout

   f_2 & 
\backslash
mathbf{1}   & 0   & 0   & 0   & 0 
\backslash
cr
\end_layout

\begin_layout Plain Layout

   f_4 & 1   & 
\backslash
mathbf{1}   & 0   & 0   & 0 
\backslash
cr
\end_layout

\begin_layout Plain Layout

   f_3 & 1   & 0   & 
\backslash
mathbf{1}   & 
\backslash
mathbf{1}   & 0 
\backslash
cr
\end_layout

\begin_layout Plain Layout

   f_5 & 0   & 1   & 
\backslash
mathbf{1}   & 
\backslash
mathbf{1}   & 0 
\backslash
cr
\end_layout

\begin_layout Plain Layout

   f_1 & 0   & 0   & 1   & 0   & 
\backslash
mathbf{1} 
\backslash
cr
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  
\backslash
subcaption{Matriz de coeficientes reordenada en forma triangular inferior
 de a bloques
\backslash
label{fig:matrix_post_Tarjan}}
\end_layout

\begin_layout Plain Layout

  
\backslash
end{subfigure}
\end_layout

\begin_layout Plain Layout

  
\backslash
hfill
\end_layout

\begin_layout Plain Layout

  
\backslash
begin{subfigure}[b]{0.3
\backslash
textwidth}
\end_layout

\begin_layout Plain Layout

  
\backslash
begin{align*}
\end_layout

\begin_layout Plain Layout

    f_2(z_2) &= 0 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

    f_4(z_1,z_2) &= 0 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

    
\backslash
mathbf{f_3(z_2,z_3,z_5)} &= 
\backslash
mathbf{0} 
\backslash

\backslash
 
\end_layout

\begin_layout Plain Layout

    
\backslash
mathbf{f_5(z_1,z_3,z_5)} &= 
\backslash
mathbf{0} 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

    f_1(z_3,z_4) &= 0 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

  
\backslash
end{align*}
\end_layout

\begin_layout Plain Layout

  
\backslash
subcaption{Sistema de ecuaciones reordenado según las dependencias entre
 las ecuaciones.
\backslash
label{fig:system_post_Tarjan}}
\end_layout

\begin_layout Plain Layout

  
\backslash
end{subfigure}
\end_layout

\begin_layout Plain Layout

  
\backslash
hspace*{
\backslash
fill}
\end_layout

\begin_layout Plain Layout

  
\backslash
caption{
\backslash
label{fig:post_Tarjan}}
\end_layout

\begin_layout Plain Layout


\backslash
end{figure}
\end_layout

\end_inset


\end_layout

\begin_layout Chapter
\begin_inset CommandInset label
LatexCommand label
name "chap:Visión-general-del"

\end_inset

Visión general del Compilador
\end_layout

\begin_layout Standard
El compilador ModelicaCC 
\begin_inset CommandInset citation
LatexCommand citep
key "lsmodelica,ModelicaCC"

\end_inset

 (Modelica C Compiler) se desarrolló como un conjunto de componentes independien
tes, cada uno de los cuales implementa una etapa diferente del proceso de
 compilación de un modelo Modelica.
 En este capítulo vamos a introducir los diferentes componentes que conforman
 el compilador Modelica explicando el rol de cada uno y cómo se componen
 para lograr la compilación de un modelo Modelica.
\end_layout

\begin_layout Section
Introducción
\end_layout

\begin_layout Standard
La compilación de un modelo Modelica es el proceso mediante el cual se transform
a un modelo de alto nivel, el cual puede contener clases y ecuaciones acausales,
 en un modelo plano, sin clases, y donde las ecuciones se encuentran ordenadas
 o causalizadas.
 Un modelo plano con las ecuaciones ordenadas de manera tal que para cada
 ecuación las variables del lado derecho se pueden considerar conocidas
 es un modelo apropiado para la generación de código C (o de cualquier otro
 lenguaje similar) y su posterior simulación.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{figure}[h]
\end_layout

\begin_layout Plain Layout

  
\backslash
centering
\end_layout

\begin_layout Plain Layout

  
\backslash
includegraphics[width=0.3
\backslash
textwidth]{graphics/BouncingBall.png}
\end_layout

\begin_layout Plain Layout

  
\backslash
caption{Bouncing Ball}
\end_layout

\begin_layout Plain Layout

  
\backslash
label{fig:bouncing_ball}
\end_layout

\begin_layout Plain Layout


\backslash
end{figure}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Como ya mencionamos en la sección 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Implementación-y-ejecución"

\end_inset

 el proceso de compilación consiste en primer lugar en un análisis sintáctico
 y semántico.
 Luego se realiza un aplanado del modelo obteniendo un modelo equivalente
 sin clases y con las ecuaciones 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+connect+
\end_layout

\end_inset

 convertidas en ecuaciones comunes.
 Luego las ecuaciones acausales del modelo aplanado se causalizan ordenándolas
 topológicamente de acuerdo a las dependencias del flujo de datos entre
 ellas.
\end_layout

\begin_layout Standard
El proceso de análisis sintáctico, semántico y aplanado es responsabilidad
 de un componente denominado flatter.
 La siguiente etapa consiste en reescribir el modelo utilizando un subconjunto
 del lenguaje Modelica denominado μModelica.
 Finalmente tenemos la causalización del conjunto de ecuaciones del modelo,
 la cual es tarea de un componente denominado causalize.
 En las siguientes secciones vamos a describir con más detalle cada una
 de estos componentes.
\end_layout

\begin_layout Standard
Para ayudar a comprender las transformaciones que realizan sobre un modelo
 Modelica los diferentes componentes vamos a utilizar un ejemplo.
 El ejemplo es el modelo orientado a objetos de un sistema mecánico.
 El sistema es una pelota que rebota contra el suelo.
\end_layout

\begin_layout Standard
En la figura 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:bouncing_ball}
\end_layout

\end_inset

 se pueden ver gráficamente el modelo.
 Nuestro modelo contempla la situación de la pelota en contacto con el suelo
 y en el aire.
 Cuando está en el aire el modelo de la misma es el de una masa puntual
 sobre la cual sólo actúa la fuerza de la gravedad y al estar en contacto
 con el piso, el modelo consiste en una masa puntual vinculada con el piso
 a través de un resorte y un amortiguador dispuestos en paralelo.
 Ni el resorte ni el amortiguador existen en la realidad pero son necesarios
 para representar la capacidad de rebotar de la pelota.
\end_layout

\begin_layout Standard
A continuación vemos el código Modelica correspondiente al modelo.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}[language=Modelica]
\end_layout

\begin_layout Plain Layout

package Example
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  connector Flange
\end_layout

\begin_layout Plain Layout

    flow Real f;
\end_layout

\begin_layout Plain Layout

    Real s;
\end_layout

\begin_layout Plain Layout

    Real v;
\end_layout

\begin_layout Plain Layout

  end Flange;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  model Ball
\end_layout

\begin_layout Plain Layout

    Example.Flange flange1;
\end_layout

\begin_layout Plain Layout

    Real v;
\end_layout

\begin_layout Plain Layout

    parameter Real m = 1, g = 9.8;
\end_layout

\begin_layout Plain Layout

    Real y;
\end_layout

\begin_layout Plain Layout

  equation
\end_layout

\begin_layout Plain Layout

    der(y) = v;
\end_layout

\begin_layout Plain Layout

    flange1.v = v;
\end_layout

\begin_layout Plain Layout

    y = flange1.s;
\end_layout

\begin_layout Plain Layout

    m * der(v) = flange1.f - m * g;
\end_layout

\begin_layout Plain Layout

  end Ball;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  model Spring
\end_layout

\begin_layout Plain Layout

    Example.Flange flange1;
\end_layout

\begin_layout Plain Layout

    Example.Flange flange2;
\end_layout

\begin_layout Plain Layout

    Real dy;
\end_layout

\begin_layout Plain Layout

    Real dv;
\end_layout

\begin_layout Plain Layout

    parameter Real b = 10, k = 10000;
\end_layout

\begin_layout Plain Layout

  equation
\end_layout

\begin_layout Plain Layout

    dv = flange1.v - flange2.v;
\end_layout

\begin_layout Plain Layout

    dy = flange1.s - flange2.s;
\end_layout

\begin_layout Plain Layout

    flange1.f = if dy < 0 then b * dv + k * dy else 0;
\end_layout

\begin_layout Plain Layout

    flange2.f = -flange1.f;
\end_layout

\begin_layout Plain Layout

  end Spring;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  model Fixed
\end_layout

\begin_layout Plain Layout

    Example.Flange flange1;
\end_layout

\begin_layout Plain Layout

    parameter Real s0 = 0;
\end_layout

\begin_layout Plain Layout

  equation
\end_layout

\begin_layout Plain Layout

    flange1.s = s0;
\end_layout

\begin_layout Plain Layout

    flange1.v = 0;
\end_layout

\begin_layout Plain Layout

  end Fixed;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  model BouncingBall
\end_layout

\begin_layout Plain Layout

    Example.Ball ball(y(start = 10));
\end_layout

\begin_layout Plain Layout

    Example.Spring spring;
\end_layout

\begin_layout Plain Layout

    Example.Fixed fixed;
\end_layout

\begin_layout Plain Layout

  equation
\end_layout

\begin_layout Plain Layout

    connect(fixed.flange1, spring.flange2);
\end_layout

\begin_layout Plain Layout

    connect(ball.flange1, spring.flange1);
\end_layout

\begin_layout Plain Layout

  end BouncingBall;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
El primer modelo del paquete es un conector que denominamos 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+Flange+
\end_layout

\end_inset

.
 Los conectores Modelica especifican la interfaz mediante la cual un componente
 interactúa con su entorno.
 El componente 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+Flange+
\end_layout

\end_inset

 declara tres variables que representan la fuerza, la posición y la velocidad
 en un punto de la interacción.
\end_layout

\begin_layout Standard
Luego tenemos otro modelo, denominado 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+Ball+
\end_layout

\end_inset

, el cual representa la pelota.
 Este modelo declara tres variables y dos constantes.
 La primer variable es de tipo 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+Flange+
\end_layout

\end_inset

 y representa la interfaz mediante la cual la pelota se conecta con su entorno;
 en nuestro caso con el amortiguador.
 Las otras dos variables representan la velocidad y la posición de la pelota.
 Las constantes representan la masa de la pelota y la fuerza de gravedad.
\end_layout

\begin_layout Standard
El modelo 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+Ball+
\end_layout

\end_inset

 además de las variables declara un conjunto de ecuaciones las cuales definen
 el comportamiento del objeto en cada instante de tiempo.
 La primer ecuación expresa que la velocidad es equivalente a la derivada
 temporal de la posición.
 La segunda ecuación establece que la velocidad de la pelota siempre es
 la misma que la de su conector.
 La tercer ecuación expresa que la posición de la pelota siempre es la misma
 que la de su conector.
 La última ecuación corresponde a la primer ley de Newton.
\end_layout

\begin_layout Standard
El siguiente modelo declarado en el paquete, denominado 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+Spring+
\end_layout

\end_inset

, es el conjunto resorte-amortiguador.
 Este modelo declara dos conectores mediante variables de tipo 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+Flange+
\end_layout

\end_inset

.
 El primer conector será utilizado para conectar el componente a la pelota
 mientras que el segundo representa la conexión del componente al piso.
 También declara dos variables de tipo 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+Real+
\end_layout

\end_inset

, una representa la diferencia de posición entre ambos conectores y la otra
 la diferencia de velocidad.
 Por último el modelo declara dos parámetros (constantes) de tipo 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+Real+
\end_layout

\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+b+
\end_layout

\end_inset

 correspondiente al coeficiente de amortiguación del amortiguador y 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+k+
\end_layout

\end_inset

 correspondiente al coeficiente de elasticidad del resorte.
 Las dos primeras ecuaciones del modelo 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+Spring+
\end_layout

\end_inset

 expresan que las variables 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+dv+
\end_layout

\end_inset

 y 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+dy+
\end_layout

\end_inset

 son equivalentes a la diferencia de velocidad y a la diferencia de posición
 de los conectores respectivamente.
 La tercer ecuación establece cual es la fuerza que ejerce el amortiguador
 cuando la pelota 
\begin_inset Quotes eld
\end_inset

toca el piso
\begin_inset Quotes erd
\end_inset

, es decir cuando 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+dy < 0+
\end_layout

\end_inset

.
 La última ecuación se corresponde con la ley de acción y reacción de Newton.
\end_layout

\begin_layout Standard
El último componente de nuestro sistema es el piso el cual se encuentra
 representado por el modelo denominado 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+Fixed+
\end_layout

\end_inset

.
 Este modelo declara una variable de tipo 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+Flange+
\end_layout

\end_inset

 que representa el conector del componente y una constante de tipo 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+Real+
\end_layout

\end_inset

 inicializada a cero que representa la posición del componente.
 Las dos ecuaciones del modelo establecen que tanto la posición como la
 velocidad del conector son siempre 0.
\end_layout

\begin_layout Standard
El sistema completo está representado por el último modelo, el modelo denominado
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+BouncingBall+
\end_layout

\end_inset

.
 Este modelo declara tres variables, la primera de tipo 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+Ball+
\end_layout

\end_inset

 representa la pelota.
 Notar que cuando se declara la variable de tipo 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+Ball+
\end_layout

\end_inset

 se inicializa la variable 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+y+
\end_layout

\end_inset

 la cual representa la posición.
 El valor asignado a dicha variable es el valor que va a tomar al inicio
 de la simulación.
 Luego de la variable de tipo 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+Ball+
\end_layout

\end_inset

 se declara una variable de tipo 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+Spring+
\end_layout

\end_inset

 representado el amortiguador.
 La tercer variable que declara el modelo 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+BouncingBall+
\end_layout

\end_inset

 es de tipo 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+Fixed+
\end_layout

\end_inset

 y representa el suelo.
\end_layout

\begin_layout Standard
En la sección 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+equation+
\end_layout

\end_inset

 del modelo 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+BouncingBall+
\end_layout

\end_inset

 se incluyen dos expresiones de tipo 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+connect+
\end_layout

\end_inset

.
 Estas dos expresiones establecen que la pelota se encuentra conectada al
 amortiguador y que el amortiguador se encuentra conectado al suelo como
 muestra la figura 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:bouncing_ball}
\end_layout

\end_inset

 .
\end_layout

\begin_layout Section
Análisis sintáctico, semántico y aplanado: flatter
\end_layout

\begin_layout Standard
El componente flatter es el encargado de realizar en primer lugar el análisis
 sintáctico y semántico del modelo que se recibe como entrada.
 Luego este componente realiza el aplanado del modelo, lo cual consiste
 en eliminar la estructura de clases del modelo orientado a objetos generando
 como salida un modelo plano.
\end_layout

\begin_layout Standard
El resultado de aplicar el componente flatter sobre el modelo anterior es
 otro modelo equivalente en el cual las clases fueron expandidas y las ecuacione
s connect se convirtieron en ecuaciones comunes.
 Las dos ecuaciones 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+connect+
\end_layout

\end_inset

 del modelo 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+BouncingBall+
\end_layout

\end_inset

 se sustituyeron por las seis últimas ecuaciones que se pueden ver en el
 modelo a continuación.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}[language=Modelica]
\end_layout

\begin_layout Plain Layout

  model BouncingBall
\end_layout

\begin_layout Plain Layout

    Real spring1_flange1_f;
\end_layout

\begin_layout Plain Layout

    Real spring1_flange1_s;
\end_layout

\begin_layout Plain Layout

    Real spring1_flange1_v;
\end_layout

\begin_layout Plain Layout

    Real spring1_flange2_f;
\end_layout

\begin_layout Plain Layout

    Real spring1_flange2_s;
\end_layout

\begin_layout Plain Layout

    Real spring1_flange2_v;
\end_layout

\begin_layout Plain Layout

    Real spring1_dy;
\end_layout

\begin_layout Plain Layout

    Real spring1_dv;
\end_layout

\begin_layout Plain Layout

    parameter Real spring1_b=10;
\end_layout

\begin_layout Plain Layout

    parameter Real spring1_k=10000;
\end_layout

\begin_layout Plain Layout

    Real fixed1_flange1_f;
\end_layout

\begin_layout Plain Layout

    Real fixed1_flange1_s;
\end_layout

\begin_layout Plain Layout

    Real fixed1_flange1_v;
\end_layout

\begin_layout Plain Layout

    parameter Real fixed1_s0=0;
\end_layout

\begin_layout Plain Layout

    Real ball1_flange1_f;
\end_layout

\begin_layout Plain Layout

    Real ball1_flange1_s;
\end_layout

\begin_layout Plain Layout

    Real ball1_flange1_v;
\end_layout

\begin_layout Plain Layout

    Real ball1_v;
\end_layout

\begin_layout Plain Layout

    parameter Real ball1_m=1;
\end_layout

\begin_layout Plain Layout

    parameter Real ball1_g=9.8;
\end_layout

\begin_layout Plain Layout

    Real ball1_y(start=10);
\end_layout

\begin_layout Plain Layout

  equation
\end_layout

\begin_layout Plain Layout

    spring1_dv = spring1_flange1_v-spring1_flange2_v;
\end_layout

\begin_layout Plain Layout

    spring1_dy = spring1_flange1_s-spring1_flange2_s;
\end_layout

\begin_layout Plain Layout

    spring1_flange1_f = if spring1_dy<0 then spring1_b*spring1_dv+spring1_k*spri
ng1_dy else 0;
\end_layout

\begin_layout Plain Layout

    spring1_flange2_f = (-spring1_flange1_f);
\end_layout

\begin_layout Plain Layout

    fixed1_flange1_s = fixed1_s0;
\end_layout

\begin_layout Plain Layout

    fixed1_flange1_v = 0;
\end_layout

\begin_layout Plain Layout

    der(ball1_y) = ball1_v;
\end_layout

\begin_layout Plain Layout

    ball1_flange1_v = ball1_v;
\end_layout

\begin_layout Plain Layout

    ball1_y = ball1_flange1_s;
\end_layout

\begin_layout Plain Layout

    ball1_m*der(ball1_v) = ball1_flange1_f-ball1_m*ball1_g;
\end_layout

\begin_layout Plain Layout

    spring1_flange2_f+fixed1_flange1_f = 0;
\end_layout

\begin_layout Plain Layout

    spring1_flange2_s = fixed1_flange1_s;
\end_layout

\begin_layout Plain Layout

    spring1_flange2_v = fixed1_flange1_v;
\end_layout

\begin_layout Plain Layout

    spring1_flange1_f+ball1_flange1_f = 0;
\end_layout

\begin_layout Plain Layout

    spring1_flange1_s = ball1_flange1_s;
\end_layout

\begin_layout Plain Layout

    spring1_flange1_v = ball1_flange1_v;
\end_layout

\begin_layout Plain Layout

  end BouncingBall; 
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Section
\begin_inset CommandInset label
LatexCommand label
name "sec:micromodelica:"

\end_inset

Simplificación a μModelica: mmo
\end_layout

\begin_layout Standard
La tarea del componente mmo es traducir el modelo aplanado a una versión
 simplificada (un subconjunto) del lenguaje Modelica denominada μModelica.
 Esta transformación del modelo es necesaria porque para la etapa final
 del proceso de compilación, la cual consiste en la generación de código
 C y la posterior simulación, se utiliza el QSS Stand–Alone Solver 
\begin_inset CommandInset citation
LatexCommand citep
key "FernandezKofman12"

\end_inset

, el cual espera modelos escritos en μModelica 
\begin_inset CommandInset citation
LatexCommand citep
key "MMO,BFF12"

\end_inset

.
\end_layout

\begin_layout Standard
El lenguaje μModelica tiene las siguientes restricciones respecto a Modelica:
\end_layout

\begin_layout Itemize
El modelo se encuentra aplanado, es decir no se permiten clases.
\end_layout

\begin_layout Itemize
Todas las variables pertenecen al tipo 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+Real+
\end_layout

\end_inset

 y solo hay tres categorías de variables: estados continuos, estados discretos
 y variables algebraicas.
\end_layout

\begin_layout Itemize
Los parámetros también son de tipo 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+Real+
\end_layout

\end_inset

.
\end_layout

\begin_layout Itemize
Sólo arreglos unidimensionales están permitidos.
 Los índices de los arrays que se encuentran dentro de cláusulas 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+for+
\end_layout

\end_inset

 están restringidos a expresiones de la forma: 
\begin_inset Formula $ai+b$
\end_inset

 donde 
\begin_inset Formula $a$
\end_inset

 y 
\begin_inset Formula $b$
\end_inset

 son expresiones enteras e 
\series bold

\begin_inset Formula $i$
\end_inset


\series default
 es el índice de iteración.
\end_layout

\begin_layout Itemize
La sección 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+equation+
\end_layout

\end_inset

 se compone de:
\end_layout

\begin_deeper
\begin_layout Itemize
definiciones de derivadas de variables de estado: 
\begin_inset Formula $der(x)=f(x(t),d,a(t),t)$
\end_inset

; en forma ODE explícita.
\end_layout

\begin_layout Itemize
definiciones de variables algebraicas: 
\begin_inset Formula $(a_{1},...,a_{n})=g(x(t),d,a(t),t)$
\end_inset

 con la restricción de que cada variable algebraica solo puede depender
 de variables de estado y de otras variables algebraicas previamente definidas.
\end_layout

\end_deeper
\begin_layout Itemize
Las discontinuidades se expresan solo por clausulas 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+when+
\end_layout

\end_inset

 y 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+elsewhen+
\end_layout

\end_inset

 dentro de la sección 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+algorithm+
\end_layout

\end_inset

.
 En ambas casos las condiciones solo pueden ser relaciones y, dentro de
 las clausulas, solo esta permitido la asignación de variables discretas
 y la re-inicialización (
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+reinit+
\end_layout

\end_inset

) de variables de estado continuas.
\end_layout

\begin_layout Standard
Estas restricciones del lenguajes son necesarias para que el simulador encuentre
 fácilmente las discontinuidades y se pueda generar código de forma sencilla.
\end_layout

\begin_layout Standard
Una especificación completa del lenguaje μModelica se puede encontrar en
 
\begin_inset CommandInset citation
LatexCommand citep
key "MMO"

\end_inset

.
\end_layout

\begin_layout Standard
A continuación podemos ver el resultado de aplicar el componente mmo sobre
 el modelo 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+BouncingBall+
\end_layout

\end_inset

 aplanado.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}[language=Modelica]
\end_layout

\begin_layout Plain Layout

  model BouncingBall
\end_layout

\begin_layout Plain Layout

      Real spring1_flange1_f;
\end_layout

\begin_layout Plain Layout

      Real spring1_flange1_s;
\end_layout

\begin_layout Plain Layout

      Real spring1_flange1_v;
\end_layout

\begin_layout Plain Layout

      Real spring1_flange2_f;
\end_layout

\begin_layout Plain Layout

      Real spring1_flange2_s;
\end_layout

\begin_layout Plain Layout

      Real spring1_flange2_v;
\end_layout

\begin_layout Plain Layout

      Real spring1_dy;
\end_layout

\begin_layout Plain Layout

      Real spring1_dv;
\end_layout

\begin_layout Plain Layout

      parameter Real spring1_b=10;
\end_layout

\begin_layout Plain Layout

      parameter Real spring1_k=10000;
\end_layout

\begin_layout Plain Layout

      Real fixed1_flange1_f;
\end_layout

\begin_layout Plain Layout

      Real fixed1_flange1_s;
\end_layout

\begin_layout Plain Layout

      Real fixed1_flange1_v;
\end_layout

\begin_layout Plain Layout

      parameter Real fixed1_s0=0;
\end_layout

\begin_layout Plain Layout

      Real ball1_flange1_f;
\end_layout

\begin_layout Plain Layout

      Real ball1_flange1_s;
\end_layout

\begin_layout Plain Layout

      Real ball1_flange1_v;
\end_layout

\begin_layout Plain Layout

      Real ball1_v;
\end_layout

\begin_layout Plain Layout

      parameter Real ball1_m=1;
\end_layout

\begin_layout Plain Layout

      parameter Real ball1_g=9.8;
\end_layout

\begin_layout Plain Layout

      Real ball1_y(start=10);
\end_layout

\begin_layout Plain Layout

      discrete Real d0;
\end_layout

\begin_layout Plain Layout

    equation
\end_layout

\begin_layout Plain Layout

      spring1_dv = spring1_flange1_v-spring1_flange2_v;
\end_layout

\begin_layout Plain Layout

      spring1_dy = spring1_flange1_s-spring1_flange2_s;
\end_layout

\begin_layout Plain Layout

      spring1_flange1_f = pre(d0)*(spring1_b*spring1_dv+spring1_k*spring1_dy)+(1
-pre(d0))*(0);
\end_layout

\begin_layout Plain Layout

      spring1_flange2_f = ((-spring1_flange1_f));
\end_layout

\begin_layout Plain Layout

      fixed1_flange1_s = fixed1_s0;
\end_layout

\begin_layout Plain Layout

      fixed1_flange1_v = 0;
\end_layout

\begin_layout Plain Layout

      der(ball1_y) = ball1_v;
\end_layout

\begin_layout Plain Layout

      ball1_flange1_v = ball1_v;
\end_layout

\begin_layout Plain Layout

      ball1_y = ball1_flange1_s;
\end_layout

\begin_layout Plain Layout

      ball1_m*der(ball1_v) = ball1_flange1_f-ball1_m*ball1_g;
\end_layout

\begin_layout Plain Layout

      spring1_flange2_f+fixed1_flange1_f = 0;
\end_layout

\begin_layout Plain Layout

      spring1_flange2_s = fixed1_flange1_s;
\end_layout

\begin_layout Plain Layout

      spring1_flange2_v = fixed1_flange1_v;
\end_layout

\begin_layout Plain Layout

      spring1_flange1_f+ball1_flange1_f = 0;
\end_layout

\begin_layout Plain Layout

      spring1_flange1_s = ball1_flange1_s;
\end_layout

\begin_layout Plain Layout

      spring1_flange1_v = ball1_flange1_v;
\end_layout

\begin_layout Plain Layout

    algorithm
\end_layout

\begin_layout Plain Layout

      when spring1_dy<0 then
\end_layout

\begin_layout Plain Layout

        d0:=1;
\end_layout

\begin_layout Plain Layout

      elsewhen spring1_dy>=0 then
\end_layout

\begin_layout Plain Layout

        d0:=0;
\end_layout

\begin_layout Plain Layout

      end when;
\end_layout

\begin_layout Plain Layout

  end BouncingBall;
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
La aplicación del componente mmo sustituyó la ecuación
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}[language=Modelica]
\end_layout

\begin_layout Plain Layout

  spring1_flange1_f =
\end_layout

\begin_layout Plain Layout

    if spring1_dy<0 then spring1_b*spring1_dv+spring1_k*spring1_dy else
 0;
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
la cual expresaba una discontinuidad por la ecuación continua
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}[language=Modelica]
\end_layout

\begin_layout Plain Layout

  spring1_flange1_f =
\end_layout

\begin_layout Plain Layout

    pre(d0)*(spring1_b*spring1_dv+spring1_k*spring1_dy)+(1-pre(d0))*(0);
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
más una clausula 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+when+
\end_layout

\end_inset

 dentro de una sección 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+algorithm+
\end_layout

\end_inset

.
 Con esta modificación el modelo resultante es compatible con la especificación
 de μModelica.
\end_layout

\begin_layout Section
Optimización: antialias
\end_layout

\begin_layout Standard
Generalmente los modelos Modelica contienen miles de ecuaciones triviales
 de la forma 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+a=b+
\end_layout

\end_inset

, la mayoría provenientes de operadores 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+connect+
\end_layout

\end_inset

.
 Con el fin de simplificar las tareas de las etapas sucesivas estas variables
 alias son eliminadas junto con las ecuaciones que las definen.
 Luego las variables eliminadas son sustituidas en las otras ecuaciones
 en las que aparecen por sus correspondientes alias.
\end_layout

\begin_layout Standard
En el modelo de la sección anterior se pueden ver varias ecuaciones que
 definen variables alias.
 El modelo que vemos a continuación es el resultado de aplicar el componente
 antialias al modelo de la sección anterior.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}[language=Modelica]
\end_layout

\begin_layout Plain Layout

  model BouncingBall
\end_layout

\begin_layout Plain Layout

    Real ball1_flange1_f;
\end_layout

\begin_layout Plain Layout

    Real ball1_v;
\end_layout

\begin_layout Plain Layout

    Real ball1_y(start=10);
\end_layout

\begin_layout Plain Layout

    discrete Real d0;
\end_layout

\begin_layout Plain Layout

    equation
\end_layout

\begin_layout Plain Layout

      der(ball1_y) = ball1_v;
\end_layout

\begin_layout Plain Layout

      der(ball1_v) = ball1_flange1_f-9.8;
\end_layout

\begin_layout Plain Layout

      (-ball1_flange1_f) = pre(d0)*(10*ball1_v+10000*ball1_y);
\end_layout

\begin_layout Plain Layout

    algorithm
\end_layout

\begin_layout Plain Layout

      when ball1_y<0 then
\end_layout

\begin_layout Plain Layout

        d0:=1;
\end_layout

\begin_layout Plain Layout

      elsewhen ball1_y>=0 then
\end_layout

\begin_layout Plain Layout

        d0:=0;
\end_layout

\begin_layout Plain Layout

      end when;
\end_layout

\begin_layout Plain Layout

  end BouncingBall;
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Este modelo es una versión equivalente pero considerablemente más simple
 (menos ecuaciones y variables) que el anterior.
\end_layout

\begin_layout Section
Causalización: causalize
\end_layout

\begin_layout Standard
La etapa de causalización tiene como principal responsabilidad la de ordenar
 las ecuaciones del modelo de manera tal que cada ecuación posea del lado
 izquierdo solo una incógnita y que las variables que aparezcan en el lado
 derecho de la ecuación sean variables conocidas, es decir variables resueltas
 por ecuaciones previas.
\end_layout

\begin_layout Standard
Al aplicar el componente causalize al modelo de la sección anterior obtenemos
 este otro modelo.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}[language=Modelica]
\end_layout

\begin_layout Plain Layout

  model BouncingBall
\end_layout

\begin_layout Plain Layout

    Real ball1_flange1_f;
\end_layout

\begin_layout Plain Layout

    Real ball1_v;
\end_layout

\begin_layout Plain Layout

    Real ball1_y(start=10);
\end_layout

\begin_layout Plain Layout

    discrete Real d0;
\end_layout

\begin_layout Plain Layout

    equation
\end_layout

\begin_layout Plain Layout

      der(ball1_y) = ball1_v;
\end_layout

\begin_layout Plain Layout

      ball1_flange1_f = (-10000*ball1_y*d0)-10*ball1_v*d0;
\end_layout

\begin_layout Plain Layout

      der(ball1_v) = ball1_flange1_f-9.8;
\end_layout

\begin_layout Plain Layout

    algorithm
\end_layout

\begin_layout Plain Layout

      when ball1_y<0 then
\end_layout

\begin_layout Plain Layout

        d0:=1;
\end_layout

\begin_layout Plain Layout

      elsewhen ball1_y>=0 then
\end_layout

\begin_layout Plain Layout

        d0:=0;
\end_layout

\begin_layout Plain Layout

      end when;
\end_layout

\begin_layout Plain Layout

  end BouncingBall;
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
El modelo de la sección anterior no podía ser resuelto secuencialmente,
 es decir comenzando por la primer ecuación, luego la segunda, y así sucesivamen
te, porque la segunda ecuación depende de la variable 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+ball1_flange1_f+
\end_layout

\end_inset

 la cual se resuelve con la tercer ecuación.
 Al aplicarle el componente causalize la segunda y la tercer ecuación se
 invierten.
 El modelo resultante sí puede ser resuelto secuencialmente.
\end_layout

\begin_layout Standard
Cabe aclarar que el resultado obtenido fue realizado con los algoritmos
 desarrollados en esta tesina.
 En la siguiente Parte veremos cómo se diseñó e implementó este componente.
\end_layout

\begin_layout Part
Contribuciones
\end_layout

\begin_layout Chapter
\begin_inset CommandInset label
LatexCommand label
name "chap:Implementación-etapa-de"

\end_inset

Implementación etapa de causalización
\end_layout

\begin_layout Standard
En este capítulo se describe la implementación de una de las etapas del
 proceso de compilación del compilador Modelica descrito en el capítulo
 anterior.
 Dicha etapa es la de causalización.
 La principal tarea que se lleva a cabo en esta etapa es la aplicación del
 algoritmo de Tarjan para lograr la transformación a la forma triangular
 inferior de a bloques (o BLT) de la matriz de incidencia asociada al sistema
 de ecuaciones diferenciales algebraicas de un modelo Modelica aplanado.
 Como ya vimos en la sección 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Transformación-BLT--"

\end_inset

 un sistema de ecuaciones reordenado según la forma BLT de su matriz asociada
 puede ser resuelto casi secuencialmente.
 Para los subsistemas de ecuaciones que no pueden ser resueltos secuencialmente
 sino que deben ser resueltos simultáneamente, denominados bucles algebraicos,
 el algoritmo de Tarjan garantiza que su tamaño es el mínimo posible.
\end_layout

\begin_layout Standard
En la sección 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Aplicacion-Tarjan-Marco-Teorico"

\end_inset

 vimos que para poder aplicar el algoritmo de Tarjan es necesario construir
 un grafo a partir de la matriz de coeficientes asociada al sistema de ecuacione
s.
 En la sección 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Construcción-del-grafo"

\end_inset

 detallamos la estructura de datos que se utilizó para la representación
 del grafo y cómo se implementó la construcción del grafo bipartito asociado
 al sistema de ecuaciones.
\end_layout

\begin_layout Standard
La aplicación del algoritmo de Tarjan se describe en la sección 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Aplicación-Tarjan-Boost"

\end_inset

.
 En esta sección además se detalla cómo se implementó la construcción del
 grafo dirigido a partir del grafo bipartito y se incluye un análisis de
 la complejidad temporal de todo el proceso de aplicación del algoritmo.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
FB: es logarítmica?
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Por último en la sección 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Optimización"

\end_inset

 se describe una novedosa optimización del proceso de causalización.
 La optimización consta de un algoritmo que se aplica previo al algoritmo
 de Tarjan.
 Dicho algoritmo tiene una complejidad logarítmica respecto de la cantidad
 de vértices del grafo y en el caso de modelos sin bucles algebraicos alcanza
 a ordenar todas las ecuaciones.
 La ventaja de este algorítmo respecto del algoritmo de Tarjan es que no
 requiere la construcción del grafo dirigido lo cual tienen una complejidad
 cuadrática en el peor caso (ver sección 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Aplicación-Tarjan-Boost"

\end_inset

).
 Si el modelo posee bucles dicho algoritmo no ordena todas las ecuaciones
 pero reduce significativamente el grafo sobre el que aplica luego el algoritmo
 de Tarjan.
\end_layout

\begin_layout Section
\begin_inset CommandInset label
LatexCommand label
name "sec:Construcción-del-grafo"

\end_inset

Construcción del grafo bipartito
\end_layout

\begin_layout Standard
La estructura de datos que utilizamos para representar el grafo de causalización
 así como las operaciones que aplicamos sobre dicha estructura son las que
 provee la biblioteca Boost Graph (BGL de aquí en adelante) 
\begin_inset CommandInset citation
LatexCommand citep
key "SJLA01"

\end_inset

.
 En la sección 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Biblioteca-Boost-Graph"

\end_inset

 explicamos brevemente las diferentes representaciones de grafos que ofrece
 la BGL y cuáles son las características de cada una.
 En la sección 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Definición-del-grafo"

\end_inset

 detallamos la estructura de datos que contruimos, a partir de una de las
 representaciones de grafos de la BGL, para representar el grafo bipartito
 asociado al sistema de ecuaciones del modelo.
\end_layout

\begin_layout Standard
Una vez introducida la estructura de datos que utilizamos como representación
 para el grafo bipartito pasamos a describir el proceso de construcción
 del mismo.
 Para construir el grafo necesitamos acceder al modelo y a partir de éste
 identificar las ecuaciones, las incógnitas y en qué ecuación aparece cada
 incógnita.
 El modelo es representado por una objeto de tipo 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+MMO_Class+
\end_layout

\end_inset

.
 La clase 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+MMO_Class+
\end_layout

\end_inset

, la cual se encuentra declarada en el archivo mmo/mmo_class.h e implementada
 en el archivo mmo/mmo_class.cpp, constituye el valor de entrada para la
 etapa de cauzalización.
 También puede verse como la interfaz entre la etapa de causalización y
 la etapa previa (ver sección 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:micromodelica:"

\end_inset

).
\end_layout

\begin_layout Standard
En general las ecuaciones son procesadas tal como se obtienen el objeto
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+MMO_Class+
\end_layout

\end_inset

.
 La única excepción son las ecuaciones de tipo 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+For-Equation+
\end_layout

\end_inset

.
 Este tipo de expresión se utiliza para describir un conjunto de ecuaciones
 que comparten cierta estructura.
 Dado que una expresión de este tipo representa en realidad varias ecuaciones
 necesitamos expandir la expresión y sustituirla en la lista de ecuaciones
 por las ecuaciones que surgen de la expansión.
 La implementación de esta tarea se describe en la sección 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Expansión-de-ecuaciones"

\end_inset

.
 La identificación de incógnitas se realiza recorriendo la tabla de símbolos,
 que también se accede vía el objeto 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+MMO_Class+
\end_layout

\end_inset

, y verificando si la variable cumple con las condiciones para que sea considera
da como una incógnita.
 Esta tarea se describe en la sección 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Identificación-de-incógnitas"

\end_inset

.
 Por último, para 
\begin_inset Quotes eld
\end_inset

trazar
\begin_inset Quotes erd
\end_inset

 las aristas del grafo es necesario determinar en qué ecuación ocurre cada
 variable.
 La implementación de una función para dicha tarea se describe en la sección
 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Ocurrencia-de-una"

\end_inset

.
\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "sub:Biblioteca-Boost-Graph"

\end_inset

Biblioteca Boost Graph
\end_layout

\begin_layout Standard
Parte de la biblioteca Boost Graph Library (BGL) es una interfaz genérica
 que permite acceder a la estructura de un grafo, pero ocultando los detalles
 de implementación.
 Es una interfaz 
\begin_inset Quotes eld
\end_inset

abierta
\begin_inset Quotes erd
\end_inset

 en el sentido de que cualquier otra biblioteca que implemente dicha interfaz
 va a ser compatible con los algoritmos genéricos de la BGL y con cualquier
 otro algoritmo genérico que también utilice esta interfaz.
 Además de la interfaz la BGL ofrece un conjunto de representaciones de
 grafos que implementan dicha interfaz 
\begin_inset CommandInset citation
LatexCommand citep
key "SJLA01"

\end_inset

.
\end_layout

\begin_layout Standard
Actualmente la BGL provee dos clases para representar grafos:
\end_layout

\begin_layout Itemize
adjacency_list
\end_layout

\begin_layout Itemize
adjacency_matrix
\end_layout

\begin_layout Standard
La clase adjacency_list implementa un grafo como una lista de adyacencia.
 Es una clase de propósito general altamente parametrizable.
 Puede ser optimizada para distintas situaciones: el grafo puede ser dirigido
 o no dirigido, admite o no aristas paralelas, acceso eficiente solo a las
 aristas salientes (out-edges) o también a las aristas entrantes (in-edges),
 inserción y remoción rápida de vértices pero con más consumo de espacio,
 etc.
\end_layout

\begin_layout Standard
La clase adjacency_matrix almacena aristas en una matriz de 
\begin_inset Formula $|V|\times|V|$
\end_inset

 (donde 
\begin_inset Formula $|V|$
\end_inset

 es la cantidad de vértices).
 Los elementos de esta matriz representan aristas en el grafo.
 Este tipo de representación es conveniente para los casos de grafos densos,
 o sea donde la cantidad de aristas se aproxima a 
\begin_inset Formula $|V|^{2}$
\end_inset

.
\end_layout

\begin_layout Standard
La ventaja de la adjacency_matrix por sobre la adjacency_list es que la
 inserción y eliminación de aristas se realiza en tiempo constante.
 No obstante hay varias desventajas.
 La primera es que la cantidad de memoria utilizada es 
\begin_inset Formula $O(V^{2})$
\end_inset

 contra 
\begin_inset Formula $O(V+E)$
\end_inset

que requiere la adjacency_list.
 La segunda es que las operaciones que recorren todas las aristas salientes
 de cada vértice demoran 
\begin_inset Formula $O(V^{2})$
\end_inset

 para la adjacency_matrix en lugar de 
\begin_inset Formula $O(V+E)$
\end_inset

 para la adjacency_list.
\end_layout

\begin_layout Standard
Ambas representaciones permiten que se adjunten objetos a los vértices y
 aristas por medio de Bundled Properties.
\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "sub:Definición-del-grafo"

\end_inset

Definición del grafo de causalización
\end_layout

\begin_layout Standard
El grafo sobre el cual se aplica el algoritmo de causalización es un grafo
 bipartito no dirigido, en donde uno de los conjuntos de vértices está asociado
 a las incógnitas de un modelo y el otro está asociado a las ecuaciones
 de dicho modelo.
 Las aristas del grafo denotan la ocurrencia de una variable en una ecuación.
 
\end_layout

\begin_layout Standard
Los grafos que representan modelos de sistemas continuos en general resultan
 ser ralos, es decir, poseen pocas aristas en relación a la cantidad de
 vértices 
\begin_inset CommandInset citation
LatexCommand citep
key "Fritzson:2003:POM:966262"

\end_inset

.
 Por este motivo la representación que decidimos utilizar para el grafo
 es adjacency_list.
\end_layout

\begin_layout Standard
En el archivo causalize/graph_definition.h se encuentra la definición del
 tipo que utilizamos para declarar el grafo de causalización, la definición
 del tipo de los objetos que adjuntamos a los vértices y la definición de
 los tipos para los vértices y aristas del grafo.
 Estas definiciones se pueden ver a continuación:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

struct VertexProperties { MMO_EquationList eqs;
\end_layout

\begin_layout Plain Layout

                          AST_ExpressionList unknowns; };
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

typedef boost::adjacency_list<boost::listS,
\end_layout

\begin_layout Plain Layout

        boost::listS, boost::undirectedS,
\end_layout

\begin_layout Plain Layout

        VertexProperties> CausalizationGraph;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

typedef CausalizationGraph::vertex_descriptor Vertex;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

typedef CausalizationGraph::edge_descriptor Edge;
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
La estructura VertexProperties define el tipo de los objetos que adjuntamos
 a los vértices del grafo.
 Estos objetos contienen las ecuaciones o incógnitas que los vértices del
 grafo representan.
 Las aristas en este caso son no dirigidas y no poseen propiedades 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb|boost::undirectedS|
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
El grafo sobre el cual aplicamos el algoritmo de causalización es de tipo
 CausalizationGraph.
 El tipo CausalizationGraph resulta de instanciar el template adjacency_list
 para que se ajuste a las necesidades del algoritmo de causalización .
 Los parámetros con los que instanciamos el template se corresponden respectivam
ente con el contenedor para las aristas del grafo, el cual en nuestro caso
 es de tipo 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+std::list+
\end_layout

\end_inset

 (
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+boost::listS+
\end_layout

\end_inset

 es un selector de tipo para 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+std::list+
\end_layout

\end_inset

), el contenedor para los vértices el cual también es 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+std::list+
\end_layout

\end_inset

, el tipo de grafo, que en nuestro caso es no dirigido, y finalmente el
 tipo de los objetos que se adjuntan a los vértices del grafo, el cual es
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+VertexProperties+
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
La elección de 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+boost::listS+
\end_layout

\end_inset

 como contenedor para las aristas y vértices del grafo se justifica ya que
 con este tipo de estructura de datos la complejidad temporal de las operaciones
 que modifican el grafo es mejor 
\begin_inset CommandInset citation
LatexCommand citep
key "SJLA01"

\end_inset

.
 Por ejemplo la operación 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+remove_vertex()+
\end_layout

\end_inset

, la cual se utiliza en la optimización del proceso de causalización (ver
 sección 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Optimización"

\end_inset

), es constante para el contenedor 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+boost::listS+
\end_layout

\end_inset

 pero 
\begin_inset Formula $O(V+E)$
\end_inset

 para el contenedor 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+boost::vecS+
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+Vertex+
\end_layout

\end_inset

 y 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+Edge+
\end_layout

\end_inset

 son los tipos de datos de los objetos que representan a los vértices y
 aristas del grafo.
\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "sub:Expansión-de-ecuaciones"

\end_inset

Expansión de ecuaciones de tipo For-Equation
\end_layout

\begin_layout Standard
Las For-Equation tienen la siguiente forma 
\begin_inset CommandInset citation
LatexCommand citep
key "Fritzson98"

\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{alltt}
\end_layout

\begin_layout Plain Layout

    
\backslash
textbf{for} for_indices 
\backslash
textbf{loop}
\end_layout

\begin_layout Plain Layout

        
\backslash
{ equation ";" 
\backslash
}
\end_layout

\begin_layout Plain Layout

    
\backslash
textbf{end for} ";"
\end_layout

\begin_layout Plain Layout


\backslash
end{alltt}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
La primer línea es lo que se denomina el prefijo de la For-Equation, el
 mismo se conforma de la siguiente manera:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{alltt}
\end_layout

\begin_layout Plain Layout

   for_indices: for_index 
\backslash
{"," for_index
\backslash
}
\end_layout

\begin_layout Plain Layout


\backslash
end{alltt}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{alltt}
\end_layout

\begin_layout Plain Layout

   for_index:
\end_layout

\begin_layout Plain Layout

       IDENT [ in expression ] 
\end_layout

\begin_layout Plain Layout


\backslash
end{alltt}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Como se puede apreciar, cada 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+for_index+
\end_layout

\end_inset

 a su vez se compone de un índice, denotado por IDENT, más una expresión
 la cual define el conjunto de valores que debe asumir dicho índice.
\end_layout

\begin_layout Standard
Hay dos aspectos de las For-Equations que no fueron contemplados en esta
 primer implementación.
 Uno es la posibilidad de definir más de un 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+for_index+
\end_layout

\end_inset

, lo cual es equivalente a escribir 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+for+
\end_layout

\end_inset

 anidados.
 El otro tiene que ver con la posibilidad de definir un rango de iteración
 implícito, es decir un 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+for_index+
\end_layout

\end_inset

 sin la 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+in expression+
\end_layout

\end_inset

.
 Estos aspectos quedan pendientes para una próxima versión.
\end_layout

\begin_layout Standard
La expansión de las For-Equations existentes en un modelo es responsabilidad
 de la función 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+process_for_equations+
\end_layout

\end_inset

 declarada en el archivo causalize/for_unrolling/process_for_equations.h.
 El prototipo de la función es el siguiente:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}
\end_layout

\begin_layout Plain Layout

  void process_for_equations(MMO_Class mmo_class);
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
La función recibe un modelo y modifica la lista de ecuaciones declaradas
 en dicho modelo eliminando las For-Equations y agregando las nuevas ecuaciones
 que resulten de la expansión de cada For-Equation.
\end_layout

\begin_layout Standard
El primer paso para expandir una For-Equation es procesar el prefijo para
 obtener el conjuntos de valores que deben tomar los índices de cada 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+for_index+
\end_layout

\end_inset

.
 Como dijimos anteriormente en esta implementación solo se soportan For-Equation
s con un solo 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+for_index+
\end_layout

\end_inset

 en el prefijo el cual a su vez debe incluir la expresión que define el
 rango, es decir no están soportados los rangos implícitos.
 Por lo tanto procesar el prefijo implica evaluar la expresión del 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+for_index+
\end_layout

\end_inset

.
 Una vez obtenido el conjunto de valores que debe asumir el índice se procede
 a instanciar las ecuaciones declaradas dentro de la For-Equation para cada
 valor del conjunto.
 Si dentro de la For-Equation hay declaradas m ecuaciones y la cantidad
 de valores del conjunto obtenido al evaluar la expresión es n el conjunto
 de nuevas ecuaciones que se agregan al modelo es m * n.
\end_layout

\begin_layout Subsubsection
Procesamiento de la expresión del índice
\end_layout

\begin_layout Standard
La expresión de cada 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+for_index+
\end_layout

\end_inset

 debe ser de tipo vector y a su vez debe ser una expresión constante 
\begin_inset CommandInset citation
LatexCommand citep
key "Fritzson98"

\end_inset

.
 Un Vector es un array de dimensión 1.
 Una expresión constante es una expresión formada por elementos constantes,
 es decir que no varían respecto del tiempo.
 Los vectores se pueden construir utilizando el operador brace 
\begin_inset Quotes eld
\end_inset

{
\begin_inset Quotes erd
\end_inset

, el operador colon 
\begin_inset Quotes eld
\end_inset

:
\begin_inset Quotes erd
\end_inset

 o una combinación de ambos.
 Ejemplos de expresiones de tipo vector son:
\end_layout

\begin_layout Itemize
{1, 2, 3, 4}
\end_layout

\begin_layout Itemize
j : k equivalente al vector de enteros {j, j+1, ..., k}, siempre y cuando j
 y k sean enteros
\end_layout

\begin_layout Itemize
j : d : k equivalente al vector de enteros {j, j+d, ..., j+n*d}, con n = (k
 – j)/d, si j, d, y k son de tipo entero.
\end_layout

\begin_layout Standard
Para poder implementar la rutina 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+process_for_equations+
\end_layout

\end_inset

 de manera independiente de la forma de la expresión del prefijo del 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+for_index+
\end_layout

\end_inset

 decidimos definir una interfaz que capture la idea de un iterador.
 La rutina 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+process_for_equation+
\end_layout

\end_inset

 utilizando esta interfaz itera a través de los valores definidos por la
 expresión del prefijo de la For-Equation.
 Esta interfaz esta declarada en el archivo causalize/for_unrolling/for_index_it
erator.h y tiene la siguiente forma:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}
\end_layout

\begin_layout Plain Layout

class ForIndexIterator {
\end_layout

\begin_layout Plain Layout

  public:
\end_layout

\begin_layout Plain Layout

    virtual bool hasNext() = 0;
\end_layout

\begin_layout Plain Layout

    virtual AST_Real next() = 0;
\end_layout

\begin_layout Plain Layout

};
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Hay dos clases que implementan esta interfaz, RangeIterator y BraceIterator,
 asociadas a los dos tipos de expresiones que se pueden encontrar en un
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+for_index+
\end_layout

\end_inset

.
 La declaración de estas clases también se encuentra en el archivo causalize/for
_unrolling/for_index_iterator.h y la implementación en el archivo causalize/for_u
nrolling/for_index_iterator.cpp.
\end_layout

\begin_layout Subsubsection
Instanciación de ecuaciones
\end_layout

\begin_layout Standard
La rutina 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+process_for_equation+
\end_layout

\end_inset

 en cada iteración (sobre el rango definido en el 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+for_index+
\end_layout

\end_inset

) instancia las ecuaciones declaradas en la For-Equation con el valor que
 toma la variable del 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+for_index+
\end_layout

\end_inset

 en esa iteración.
 Para realizar la instanciación fue necesario escribir una clase que permita
 realizar la evaluación algebraica de una expresión.
 Esta clase es 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+EvalExp+
\end_layout

\end_inset

, su declaración se puede encontrar en el archivo util/ast_visitors/evalexp.h
 y su implementación en el archivo util/ast_visitors/evalexp.cpp.
\end_layout

\begin_layout Standard
Por ejemplo el siguiente código:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}
\end_layout

\begin_layout Plain Layout

model Adv
\end_layout

\begin_layout Plain Layout

  Real a[5]; 
\end_layout

\begin_layout Plain Layout

equation
\end_layout

\begin_layout Plain Layout

  for i in 1:5 loop
\end_layout

\begin_layout Plain Layout

    a[i]=i;   
\end_layout

\begin_layout Plain Layout

  end for; 
\end_layout

\begin_layout Plain Layout

end Adv;
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
es expandido en:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}
\end_layout

\begin_layout Plain Layout

model Adv
\end_layout

\begin_layout Plain Layout

  Real a[5];
\end_layout

\begin_layout Plain Layout

equation   
\end_layout

\begin_layout Plain Layout

  a[1] = 1;
\end_layout

\begin_layout Plain Layout

  a[2] = 2;
\end_layout

\begin_layout Plain Layout

  a[3] = 3;
\end_layout

\begin_layout Plain Layout

  a[4] = 4;
\end_layout

\begin_layout Plain Layout

  a[5] = 5; 
\end_layout

\begin_layout Plain Layout

end Adv; 
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "sub:Identificación-de-incógnitas"

\end_inset

Identificación de incógnitas
\end_layout

\begin_layout Standard
El grafo inicialmente cuenta con un nodo para cada ecuación.
 Luego debemos crear un nodo para cada incógnita.
 Para poder construir el grafo sobre el cual se aplica el algoritmo de causaliza
ción es necesario identificar cuáles de todas las variables declaradas en
 el modelo son incógnitas y cuáles no.
 Una variable es una incógnita si satisface las siguientes condiciones:
\end_layout

\begin_layout Itemize
Es una variable continua.
 Es decir que varia de manera continua respecto del tiempo (no un parámetro
 o constante).
\end_layout

\begin_layout Itemize
No es un estado.
 Un variable es un estado si aparece su derivada en función del tiempo.
\end_layout

\begin_layout Itemize
Es la derivada respecto del tiempo de una variable.
\end_layout

\begin_layout Standard
La clase encargada de identificar y recolectar las incógnitas es UnknownsCollect
or definida en el archivo causalize/unknowns_collector.h.
 Esta clase recibe como parámetro de su constructor la instancia del modelo
 que se está causalizando, es decir un objeto de tipo 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+MMO_Class+
\end_layout

\end_inset

.
 La interfaz de la clase está compuesta por un único método con la siguiente
 firma:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}
\end_layout

\begin_layout Plain Layout

  AST_ExpressionList collectUnknowns();
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
El procedimiento para identificar las incógnitas es bastante sencillo.
 Como primer paso se identifican las variables que son estados.
 Luego se recorre la tabla de símbolos, a la cual se accede a partir del
 objeto 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+MMO_Class+
\end_layout

\end_inset

, y para cada variable se verifican las condiciones presentadas anteriormente,
 que sea continua y que no sea un estado.
 Si la variable satisface las condiciones se la agrega a la lista de incógnitas.
\end_layout

\begin_layout Standard
El proceso de identificación de estados es responsabilidad de la clase StateVari
ablesFinder declarada en el archivo causalize/state_variables_finder.h.
 De la misma manera que el UnkownsCollector esta clase recibe como parámetro
 de su constructor la instancia del modelo que se está causalizando.
 Su interfaz está compuesta por un único método cuya firma es la siguiente:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}
\end_layout

\begin_layout Plain Layout

  void findStateVariables();
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Este método recorre la estructura de las ecuaciones del modelo en busca
 de derivadas.
 Cada vez que encuentra una expresión de este tipo marca en la tabla de
 símbolos la variable, sobre la cual se aplica la derivada, como estado.
 En esta versión del algoritmo, y por una cuestión de simplicidad, solo
 están soportadas derivadas de una sola variable.
\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "sub:Ocurrencia-de-una"

\end_inset

Ocurrencia de una incógnita en una ecuación
\end_layout

\begin_layout Standard
Cada arista del grafo de causalización se corresponde con la ocurrencia
 de una incógnita en una ecuación.
 Para poder construir el grafo necesitamos una manera de determinar si una
 incógnita aparece (o es usada) en una ecuación.
 Resolver esto implica que dada una incógnita y una ecuación, necesitamos
 comparar la incógnita con cada una de las expresiones que componen la ecuación.
\end_layout

\begin_layout Standard
Dado que las ecuaciones están representadas mediante una estructura de tipo
 AST (abstract syntax tree), y dado que la forma más adecuada de implementar
 una algoritmo que opere sobre una estructura de este tipo es mediante la
 aplicación del patrón de diseño visitor 
\begin_inset CommandInset citation
LatexCommand citep
key "gamma1994design"

\end_inset

, lo que hicimos fue justamente eso, escribir una clase que implementa el
 patrón visitor.
 La clase es 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+contains+
\end_layout

\end_inset

 y se puede encontrar en el archivo util/ast_visitors/contains.h.
 La declaración de la clase se puede ver a continuación.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}
\end_layout

\begin_layout Plain Layout

  class contains: public boost::static_visitor<bool> {
\end_layout

\begin_layout Plain Layout

  public:
\end_layout

\begin_layout Plain Layout

    contains(Expression);
\end_layout

\begin_layout Plain Layout

    bool operator()(Integer v) const;
\end_layout

\begin_layout Plain Layout

    bool operator()(Boolean v) const;
\end_layout

\begin_layout Plain Layout

    bool operator()(String v) const;
\end_layout

\begin_layout Plain Layout

    bool operator()(Name v) const;
\end_layout

\begin_layout Plain Layout

    bool operator()(Real v) const;
\end_layout

\begin_layout Plain Layout

    bool operator()(SubEnd v) const;
\end_layout

\begin_layout Plain Layout

    bool operator()(SubAll v) const;
\end_layout

\begin_layout Plain Layout

    bool operator()(BinOp) const;
\end_layout

\begin_layout Plain Layout

    bool operator()(UnaryOp) const;
\end_layout

\begin_layout Plain Layout

    bool operator()(Brace) const;
\end_layout

\begin_layout Plain Layout

    bool operator()(Bracket) const;
\end_layout

\begin_layout Plain Layout

    bool operator()(Call) const;
\end_layout

\begin_layout Plain Layout

    bool operator()(FunctionExp) const;
\end_layout

\begin_layout Plain Layout

    bool operator()(ForExp) const;
\end_layout

\begin_layout Plain Layout

    bool operator()(IfExp) const;
\end_layout

\begin_layout Plain Layout

    bool operator()(Named) const;
\end_layout

\begin_layout Plain Layout

    bool operator()(Output) const;
\end_layout

\begin_layout Plain Layout

    bool operator()(Reference) const;
\end_layout

\begin_layout Plain Layout

    bool operator()(Range) const;
\end_layout

\begin_layout Plain Layout

    Expression exp;
\end_layout

\begin_layout Plain Layout

  }; 
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
La clase 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+contains+
\end_layout

\end_inset

 implementa el patrón visitor heredando de 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+static_visitor+
\end_layout

\end_inset

 la cual pertenece a la biblioteca Boost Variant 
\begin_inset CommandInset citation
LatexCommand citep
key "Schling:2011:BCL:2049814"

\end_inset

.
 Esto permite aplicar el visitor sobre una expresión utilizando la función
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+apply_visitor+
\end_layout

\end_inset

 también perteneciente a la biblioteca Boost.
 Para ver cómo se utiliza la clase contains mostramos un fragmento del código
 de la clase 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+CausalizationStrategy+
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}
\end_layout

\begin_layout Plain Layout

  contains occurrs(_graph[unknownVertex].unknown); 
\end_layout

\begin_layout Plain Layout

  const bool rl = boost::apply_visitor(occurrs,eq.left_ref());
\end_layout

\begin_layout Plain Layout

  const bool ll = boost::apply_visitor(occurrs,eq.right_ref());
\end_layout

\begin_layout Plain Layout

  if(rl || ll) {
\end_layout

\begin_layout Plain Layout

    add_edge(eqVertex, unknownVertex, _graph);
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Lo que vemos en esta porción de código es la declaración del objeto 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+occurs+
\end_layout

\end_inset

 de tipo 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+contains+
\end_layout

\end_inset

.
 Vemos que el objeto se inicializa con una incógnita.
 Luego mediante la función 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+apply_visitor+
\end_layout

\end_inset

 se aplica el visitor 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+occurs+
\end_layout

\end_inset

 al lado izquierdo y posteriormente al lado derecho de una ecuación.
 Finalmente, si la incógnita pertenece a la ecuación, se agrega una arista
 al grafo.
\end_layout

\begin_layout Section
\begin_inset CommandInset label
LatexCommand label
name "sub:Aplicación-Tarjan-Boost"

\end_inset

Aplicación del algoritmo de Tarjan
\end_layout

\begin_layout Standard
En la sección 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Aplicacion-Tarjan-Marco-Teorico"

\end_inset

 explicamos el algoritmo de Tarjan y de qué forma aplica dicho algoritmo
 al problema de causalización de un sistema de ecuaciones diferenciales
 algebraicas.
 Vimos que para poder aplicar el algoritmo es necesario obtener un grafo
 dirigido a partir del grafo no dirigido asociado al sistema de ecuaciones.
 Este grafo dirigido lo obtenemos aplicando los pasos enumerados en la sección
 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Aplicacion-Tarjan-Marco-Teorico"

\end_inset

 y que aquí recordamos:
\end_layout

\begin_layout Enumerate
Calculamos un matching máximo sobre el grafo original.
\end_layout

\begin_layout Enumerate
Los vértices correspondientes a incógnitas se colapsan contra su pareja
 correspondiente en el conjunto de vértices asociados a ecuaciones.
\end_layout

\begin_layout Enumerate
Las aristas que no pertenecen al emparejamiento se reemplazan por aristas
 dirigidas entrantes en los vértices correspondientes a incógnitas.
\end_layout

\begin_layout Standard
Estos conceptos fueron implementados en la función 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+apply_Tarjan+
\end_layout

\end_inset

 declarada en el archivo causalize/apply_Tarjan.h.
 La firma de la función es la siguiente:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}
\end_layout

\begin_layout Plain Layout

  int apply_Tarjan(CausalizationGraph &graph, std::map<int, causalize::Component
> &components);
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
El tipo 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+causalize::Component+
\end_layout

\end_inset

 representa un componenten fuertemente conexo.
 Éste se encuentra definido en el mismo archivo que la función 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+apply_Tarjan+
\end_layout

\end_inset

 y se declaró de la siguiente manera:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}
\end_layout

\begin_layout Plain Layout

  namespace causalize {
\end_layout

\begin_layout Plain Layout

    struct _Component {
\end_layout

\begin_layout Plain Layout

      std::list<Vertex> *uVertices;
\end_layout

\begin_layout Plain Layout

      std::list<Vertex> *eqVertices;
\end_layout

\begin_layout Plain Layout

    };
\end_layout

\begin_layout Plain Layout

    typedef _Component *Component;
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
La estructura 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+_Component+
\end_layout

\end_inset

 posee dos listas de vértices, una lista corresponde a los vértices de un
 componente fuertemente conexo asociados a ecuaciones del modelo, la otra
 lista corresponde los vértices del mismo componente fuertemente conexo
 asociados a incógnitas del modelo.
\end_layout

\begin_layout Standard
La función 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+apply_Tarjan+
\end_layout

\end_inset

 toma dos argumentos.
 El primero es el grafo sobre el cual se va a aplicar el algoritmo de Tarjan.
 El segundo argumento es una referencia a un diccionario o mapa ordenado
 donde las clave son índices y los valores son componentes fuertemente conexos
 representados por objetos de tipo 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+Component+
\end_layout

\end_inset

.
 Dicho diccionario será populado con los componentes fuertemente conexos
 identificados por el algoritmo de Tarjan.
 Los índices corresponden a los identificadores que le asigna el algoritmo
 a cada componente conforme lo va encontrando.
 El valor de retorno de la función es la cantidad de componentes fuertemente
 conexos encontrados.
\end_layout

\begin_layout Standard
Para calcular el matching sobre el grafo no dirigido utilizamos la función
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+checked_edmonds_maximum_cardinality_matching+
\end_layout

\end_inset

 provista por la Boost Graph Library 
\begin_inset CommandInset citation
LatexCommand citep
key "SJLA01"

\end_inset

.
 Una vez obtenido el matching construímos el grafo dirigido siguiendo los
 pasos descritos anteriormente.
 Luego se aplica la función provista por la BGL 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+strong_components+
\end_layout

\end_inset

, la cual implementa el algoritmo de Tarjan, sobre el grafo dirigido.
 Finalmente se popula el diccionario 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+components+
\end_layout

\end_inset

 a partir del resultado arrojado por la función 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+strong_components+
\end_layout

\end_inset

.
\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "sub:ComplejidadTarjan1"

\end_inset

Complejidad
\end_layout

\begin_layout Standard
En la siguiente descripción de la complejidad de la función 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+apply_Tarjan+
\end_layout

\end_inset

 utilizamos 
\begin_inset Formula $O(\dfrac{E}{V})$
\end_inset

 para expresar la complejidad temporal de las operaciones que recorren la
 lista de adyacencia de un vértice.
 La expresión 
\begin_inset Formula $\dfrac{E}{V}$
\end_inset

 representa la cantidad promedio de aristas por vértice.
 En el peor caso la longitud de la lista de adyancencia de un vértice es
 
\begin_inset Formula $V$
\end_inset

.
 Para los casos de grafos esparcidos (o poco densos) 
\begin_inset Formula $\dfrac{E}{V}$
\end_inset

 es mucho más chico que 
\begin_inset Formula $V$
\end_inset

 y puede ser considerado constante 
\begin_inset CommandInset citation
LatexCommand citep
key "SJLA01"

\end_inset

.
\end_layout

\begin_layout Standard
En nuestro caso los grafos, que surgen de la matriz de coeficientes de un
 modelo Modelica aplanado, suelen ser ralos 
\begin_inset CommandInset citation
LatexCommand citep
key "elmqvist2005"

\end_inset

 por lo tanto podemos asumir 
\begin_inset Formula $\dfrac{E}{V}$
\end_inset

 constante en nuestros cálculos.
 A dicho valor constante haremos referencia mediante la letra 
\begin_inset Formula $K$
\end_inset

.
\end_layout

\begin_layout Standard
Las cuatro tareas que definen la complejidad de la función 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+apply_Tarjan+
\end_layout

\end_inset

 son
\end_layout

\begin_layout Itemize
el cálculo del matching mediante la función 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+checked_edmonds_maximum_cardinality_matching+
\end_layout

\end_inset

, 
\end_layout

\begin_layout Itemize
la construcción del grafo dirigido, 
\end_layout

\begin_layout Itemize
la aplicación del algoritmo de Tarjan implementado por la función 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+strong_components+
\end_layout

\end_inset

 y 
\end_layout

\begin_layout Itemize
la construcción del objeto 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+components+
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Como se puede corroborar en 
\begin_inset CommandInset citation
LatexCommand citep
key "SJLA01"

\end_inset

 la complejidad de las funciones 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+checked_edmonds_maximum_cardinality_matching+
\end_layout

\end_inset

 y 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+strong_components+
\end_layout

\end_inset

 son 
\begin_inset Formula $O(V\times E\times4)$
\end_inset

 y 
\begin_inset Formula $O(V+E)$
\end_inset

 respectivamente.
 Considerando que en nuestro caso el grafo es bipartito tenemos que 
\begin_inset Formula $E\geqslant\dfrac{V}{2}$
\end_inset

 por lo tanto la complejidad del cálculo del matching es 
\begin_inset Formula $O(V^{2})$
\end_inset

.
\end_layout

\begin_layout Standard
Para que se entienda mejor el calculo del costo temporal de la construcción
 del grafo dirigido vamos a mostrar el fragmento de código (extraído del
 archivo causalize/apply_Tarjan.cpp) que realiza dicha tarea.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}
\end_layout

\begin_layout Plain Layout

void buildCollapsedGraph(CausalizationGraph& graph, DirectedGraph& digraph)
 {
\end_layout

\begin_layout Plain Layout

  // Create the vertices on the directed graph
\end_layout

\begin_layout Plain Layout

  CausalizationGraph::vertex_iterator vi, vi_end;
\end_layout

\begin_layout Plain Layout

  for(boost::tie(vi,vi_end) = vertices(graph); vi != vi_end; ++vi) {
\end_layout

\begin_layout Plain Layout

    if (graph[*vi].type == E) {
\end_layout

\begin_layout Plain Layout

      DGVertex v = add_vertex(digraph);
\end_layout

\begin_layout Plain Layout

      _collapsed2original[v]=*vi;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  // Create the edges on the directed graph
\end_layout

\begin_layout Plain Layout

  DirectedGraph::vertex_iterator vj, vj_end;
\end_layout

\begin_layout Plain Layout

  for(boost::tie(vj,vj_end) = vertices(digraph); vj != vj_end; ++vj) {
\end_layout

\begin_layout Plain Layout

    CausalizationGraph::out_edge_iterator ek, ek_end;
\end_layout

\begin_layout Plain Layout

    Vertex originalEqVertex = _collapsed2original[*vj];
\end_layout

\begin_layout Plain Layout

    Vertex uMatchingVertex = _matching[originalEqVertex];
\end_layout

\begin_layout Plain Layout

    for(boost::tie(ek,ek_end) = out_edges(uMatchingVertex, graph); ek !=
 ek_end; ++ek) {
\end_layout

\begin_layout Plain Layout

        Vertex eqAdjacentVertex = target(*ek, graph);
\end_layout

\begin_layout Plain Layout

        if(eqAdjacentVertex != originalEqVertex) {
\end_layout

\begin_layout Plain Layout

          boost::add_edge(original2collapsed(eqAdjacentVertex), *vj, digraph);
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
El primer 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+for+
\end_layout

\end_inset

 que se ve en el código de la función 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+buildCollapsedGraph+
\end_layout

\end_inset

, el cual recorre los vértices del grafo original y por cada vértice asociado
 a una ecuación (vértice de tipo 
\begin_inset Quotes eld
\end_inset

E
\begin_inset Quotes erd
\end_inset

) agrega un vértice al nuevo grafo dirigido, posee una complejidad lineal
 respecto de 
\begin_inset Formula $V$
\end_inset

, es decir 
\begin_inset Formula $O(V)$
\end_inset

.
 Esto es así dado que la función 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+add_vertex+
\end_layout

\end_inset

 se ejecuta en tiempo amortizado constante 
\begin_inset CommandInset citation
LatexCommand citep
key "SJLA01"

\end_inset

.
 La complejidad del segundo 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+for+
\end_layout

\end_inset

 se puede representar por la siguiente expresión 
\begin_inset Formula $O(V\times\dfrac{E}{V})$
\end_inset

.
 Ya que 
\begin_inset Formula $\dfrac{E}{V}$
\end_inset

 se puede asumir constante el segundo for de la función 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+buildCollapsedGraph+
\end_layout

\end_inset

 tiene una complejidad de 
\begin_inset Formula $O(V)$
\end_inset

.
 Podemos concluir que la construcción del grafo dirigido a partir del grafo
 no dirigido se ejecuta en tiempo lineal.
\end_layout

\begin_layout Standard
Finalmente calculamos la complejidad de la porción de código que popula
 el objeto 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+components+
\end_layout

\end_inset

, uno de los parámetro de la función 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+apply_Tarjan+
\end_layout

\end_inset

.
 A continuación vemos la porción de código mencionada la cual es parte de
 la función 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+apply_Tarjan+
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}
\end_layout

\begin_layout Plain Layout

  for (std::map<DGVertex,int>::iterator it=vertex2component.begin(); it!=vertex2c
omponent.end(); ++it) {
\end_layout

\begin_layout Plain Layout

        DGVertex dgVertex = it->first;
\end_layout

\begin_layout Plain Layout

        int componentIndex = it->second;
\end_layout

\begin_layout Plain Layout

        Vertex eqVertex = _collapsed2original[dgVertex];
\end_layout

\begin_layout Plain Layout

        Vertex uVertex = _matching[eqVertex];
\end_layout

\begin_layout Plain Layout

        std::map<int, causalize::Component>::iterator componentsIt = components.f
ind(componentIndex);
\end_layout

\begin_layout Plain Layout

        if(componentsIt == components.end()){
\end_layout

\begin_layout Plain Layout

          causalize::Component component = new causalize::_Component;
\end_layout

\begin_layout Plain Layout

          std::list<Vertex> *uVertices = new std::list<Vertex>;
\end_layout

\begin_layout Plain Layout

          uVertices->push_back(uVertex);
\end_layout

\begin_layout Plain Layout

          component->uVertices = uVertices;
\end_layout

\begin_layout Plain Layout

          std::list<Vertex> *eqVertices = new std::list<Vertex>;
\end_layout

\begin_layout Plain Layout

          eqVertices->push_back(eqVertex);
\end_layout

\begin_layout Plain Layout

          component->eqVertices = eqVertices;
\end_layout

\begin_layout Plain Layout

          components[componentIndex] = component;
\end_layout

\begin_layout Plain Layout

        } else {
\end_layout

\begin_layout Plain Layout

          causalize::Component component = componentsIt->second;
\end_layout

\begin_layout Plain Layout

          std::list<Vertex> *uVertices = component->uVertices;
\end_layout

\begin_layout Plain Layout

          uVertices->push_back(uVertex);
\end_layout

\begin_layout Plain Layout

          std::list<Vertex> *eqVertices = component->eqVertices;
\end_layout

\begin_layout Plain Layout

          eqVertices->push_back(eqVertex);
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
El mapa 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+vertex2component+
\end_layout

\end_inset

 asocia a cada vértice del grafo dirigido sobre el cual aplicamos la función
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+strong_components+
\end_layout

\end_inset

 el número de componente al cual pertenece.
 La cantidad de elementos de dicho mapa es 
\begin_inset Formula $\dfrac{V}{2}$
\end_inset

.
 Dentro del bucle que itera sobre el mencionado mapa se ven operaciones
 de acceso sobre otros tres mapas ordenados que son 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+_collapsed2original+
\end_layout

\end_inset

 que asocia cada vértice del grafo dirigido con un vértice del grafo original,
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+_matching+
\end_layout

\end_inset

 el cual contiene el matching calculado sobre el grafo original y 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+_components+
\end_layout

\end_inset

.
 Las cantidad de elementos de estos tres mapas son respectivamente 
\begin_inset Formula $\dfrac{V}{2}$
\end_inset

, 
\begin_inset Formula $V$
\end_inset

 y 
\begin_inset Formula $V$
\end_inset

 también para 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+_components+
\end_layout

\end_inset

 en el peor caso.
 Dado que estos mapas son del tipo 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+map+
\end_layout

\end_inset

, el tipo que representa los mapas ordenados en C++, la operación de acceso
 por clave tiene una complejidad logarítmica.
 La complejidad de esta porción de código es 
\begin_inset Formula $O(\dfrac{V}{2}\times(\log(\dfrac{V}{2})+\log(V)+\log(V)))$
\end_inset

 lo cual es equivalente a 
\begin_inset Formula $O(V\times\log(V))$
\end_inset

.
\end_layout

\begin_layout Standard
Habiendo calculado la complejidad de cada parte de la función 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+apply_Tarjan+
\end_layout

\end_inset

 concluimos que la complejidad total de la función queda condicionada por
 la complejidad del cálculo del matching la cual es cuadrática.
 Es decir, la complejidad de la función 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+apply_Tarjan+
\end_layout

\end_inset

 es 
\begin_inset Formula $O(V^{2})$
\end_inset

.
\end_layout

\begin_layout Section
\begin_inset CommandInset label
LatexCommand label
name "sub:Optimización"

\end_inset

Optimización del proceso de causalización
\end_layout

\begin_layout Standard
En esta sección se describe la implementación de un algoritmo simple el
 cual permite optimizar el proceso de causalización de ecuaciones.
 Dicho algorítmo presenta una mejor complejidad que el algoritmo de Tarjan
 para los casos que no presentan bucles algebraicos.
 La característica principal es que aplica directamente sobre el grafo no
 dirigido lo cual ahorra el costo del cálculo del matching que sí es necesario
 para poder aplicar el algorítmo de Tarjan.
 El algorítmo representa una optimización del proceso en todos los casos,
 es decir inclusive en aquellos que sí presentan bucles algebraicos.
 En estos casos, el algoritmo simple causaliza todas las ecuaciones que
 no se encuentren involucradas en un bucle algebraico dejando un modelo
 mucho más reducido.
 Finalmente el algoritmo de Tarjan se aplica sobre el modelo reducido resultante
 de aplicar el algoritmo simple.
\end_layout

\begin_layout Subsection
Un algoritmo simple para obtener la transformación BLT
\end_layout

\begin_layout Standard
En el capítulo 
\shape italic
Differential Algebraic Equations
\shape default
 del libro 
\shape italic
Continuous System Simulation
\shape default
 
\begin_inset CommandInset citation
LatexCommand citep
key "CK06"

\end_inset

 se presenta un algoritmo para obtener la transformación BLT de la matriz
 de coeficientes asociada a un sistema de ecuaciones diferenciales algebraicas.
 El algoritmo aplica sobre el grafo bipartito que se obtiene a partir del
 sistema de ecuaciones diferenciales algebraicas de la misma manera que
 lo hace la función 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+apply_Tarjan+
\end_layout

\end_inset

 de la sección anterior.
\end_layout

\begin_layout Standard
Suponiendo que un grafo que admite aristas de colores y que inicialmente
 las aristas del grafo son de color negro el algoritmo se puede definir
 a partir de las siguientes reglas:
\end_layout

\begin_layout Enumerate
para cada ecuación acausal, si la ecuación posee solo una arista negra,
 coloreamos esa arista de rojo, seguimos esa arista hacia la variable que
 se encuentra en el otro extremo, y coloreamos el resto de las arista que
 salen de dicha variable con azul.
 Enumeramos la ecuación utilizando el menor número que se encuentre libre
 comenzando desde 1.
\end_layout

\begin_layout Enumerate
para cada incógnita, si posee solo una arista negra la coloreamos de rojo,
 seguimos dicha arista hasta la ecuación correspondiente y coloreamos el
 resto de las aristas de dicha ecuación en azul.
 Enumeramos la ecuación utilizando el número más alto comenzando con 
\emph on
n
\emph default
, donde 
\emph on
n
\emph default
 es el número de ecuaciones.
\end_layout

\begin_layout Standard
Una ecuación es causal si posee solo una arista roja.
 En cambio una ecuación que posee solo aristas azules o negras es una ecuación
 acausal.
 De la misma manera una variable es conocida si posee solo una arista roja
 y es una incógnita si posee solo aristas azules o negras.
 Ninguna ecuación o variable debe tener más de una arista roja.
\end_layout

\begin_layout Standard
Si el modelo no posee lazos algebraicos este algoritmo va a ser capaz de
 causalizar todas las ecuaciones.
 Esto significa que en cada vértice se conecta una y solo una arista roja.
 En el caso contrario el algoritmo va a llegar a un punto en el que las
 ecuaciones acausales y las incógnitas restantes van a poseer todas más
 de una arista con lo cual no va a ser posible aplicar ninguna de las reglas
 antes descriptas.
\end_layout

\begin_layout Standard
En la figura 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:alg_simple_step_by_step}
\end_layout

\end_inset

 podemos ver la aplicación del algoritmo sobre un grafo de ejemplo
\begin_inset Foot
status open

\begin_layout Plain Layout
En caso de imprimir este trabajo en blanco y negro notar que las aristas
 dibujadas con linea punteada se corresponden con aristas de color rojo
 y las aristas dibujadas con linea semi-punteada se corresponden con aristas
 de color azul.
\end_layout

\end_inset

.
 El grafo lo generamos a partir del sistema de ecuaciones 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:ej_transformacion_blt_sis"

\end_inset

 de la sección 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Transformación-BLT--"

\end_inset

.
 En la figura 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:ej_alg_simple_2}
\end_layout

\end_inset

 se ve el estado del grafo luego de la aplicación de la regla número 1 del
 algoritmo, es decir luego de iterar sobre la lista de vértices asociados
 a ecuaciones acausales.
 Luego de esta primer iteración la ecuación 
\begin_inset Formula $h{}_{2}$
\end_inset

 pasa a la lista de ecuaciones causales (o causalizadas) y recibe el índice
 número 1.
 La aplicación de la regla número 2 del algoritmo da como resultado la causaliza
ción de la ecuación 
\begin_inset Formula $h{}_{1}$
\end_inset

 con índice 3.
 Esto se puede ver en la figura 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:ej_alg_simple_3}
\end_layout

\end_inset

.
 Finalmente en la figura 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:ej_alg_simple_4}
\end_layout

\end_inset

 vemos el resultado de la última iteración del algoritmo, la cual consta
 de aplicar nuevamente la regla 1.
 En esta última figura se puede apreciar el nuevo ordenamiento que se le
 ha dado al sistema de ecuaciones, quedando la ecuación 
\begin_inset Formula $h{}_{2}$
\end_inset

 en la primer posición, seguida de 
\begin_inset Formula $h{}_{3}$
\end_inset

 y 
\begin_inset Formula $h{}_{1}$
\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{figure}[H]
\end_layout

\begin_layout Plain Layout

    
\backslash
centering
\end_layout

\begin_layout Plain Layout

    
\backslash
begin{subfigure}[b]{0.4
\backslash
textwidth}
\end_layout

\begin_layout Plain Layout

    
\backslash
includegraphics[width=0.8
\backslash
textwidth]{graphics/revision/ej_alg_simple_1.png}
\end_layout

\begin_layout Plain Layout

    
\backslash
caption{
\backslash
label{fig:ej_alg_simple_1}}
\end_layout

\begin_layout Plain Layout

  
\backslash
end{subfigure}
\end_layout

\begin_layout Plain Layout

  
\backslash
begin{subfigure}[b]{0.4
\backslash
textwidth}
\end_layout

\begin_layout Plain Layout

    
\backslash
includegraphics[width=0.8
\backslash
textwidth]{graphics/revision/ej_alg_simple_2.png}
\end_layout

\begin_layout Plain Layout

    
\backslash
caption{
\backslash
label{fig:ej_alg_simple_2}}
\end_layout

\begin_layout Plain Layout

  
\backslash
end{subfigure}
\end_layout

\begin_layout Plain Layout

  
\backslash
begin{subfigure}[b]{0.4
\backslash
textwidth}
\end_layout

\begin_layout Plain Layout

    
\backslash
includegraphics[width=0.8
\backslash
textwidth]{graphics/revision/ej_alg_simple_3.png}
\end_layout

\begin_layout Plain Layout

    
\backslash
caption{
\backslash
label{fig:ej_alg_simple_3}}
\end_layout

\begin_layout Plain Layout

  
\backslash
end{subfigure}
\end_layout

\begin_layout Plain Layout

  
\backslash
begin{subfigure}[b]{0.4
\backslash
textwidth}
\end_layout

\begin_layout Plain Layout

    
\backslash
includegraphics[width=0.8
\backslash
textwidth]{graphics/revision/ej_alg_simple_4.png}
\end_layout

\begin_layout Plain Layout

    
\backslash
caption{
\backslash
label{fig:ej_alg_simple_4}}
\end_layout

\begin_layout Plain Layout

  
\backslash
end{subfigure}
\end_layout

\begin_layout Plain Layout

  
\backslash
caption{
\backslash
label{fig:alg_simple_step_by_step}}
\end_layout

\begin_layout Plain Layout


\backslash
end{figure}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Tal como esta planteado el algoritmo en el libro 
\begin_inset CommandInset citation
LatexCommand citep
key "CK06"

\end_inset

 la complejidad es cuadrática.
 Para entender porque esto es así presentamos en pseudo-código y de manera
 muy simplificada el algoritmo:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}
\end_layout

\begin_layout Plain Layout

  do {
\end_layout

\begin_layout Plain Layout

    for each v of [lista de ecuaciones acausales] {
\end_layout

\begin_layout Plain Layout

	    aplicar regla 1 sobre v
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

    for each v of [lista de incognitas] {
\end_layout

\begin_layout Plain Layout

	  aplicar regla 2 sobre v
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

  } while (queden vertices por causalizar &&
\end_layout

\begin_layout Plain Layout

           se haya causalizado al menos un vertice en esta iteracion)
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
El peor caso para este algoritmo es que se causalize un solo par ecuación-incógn
ita por iteración del bucle while.
 La cantidad de operaciones para este peor caso serian:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
V+(V-2)+((V-2)-2)+\ldots=\sum_{i=0}^{\frac{V}{2}}(V-2i)=\frac{V^{2}}{4}-\frac{V}{2}
\]

\end_inset


\end_layout

\begin_layout Standard
de donde vemos que finalmente esta versión simplificada (si fuera implementada
 como está descripta) sigue teniendo complejidad cuadrática.
\end_layout

\begin_layout Subsection
Optimización del algoritmo simple
\end_layout

\begin_layout Standard
Si modificamos el algoritmo de manera tal que no sea necesario recorrer
 todos los vértices correspondientes a ecuaciones ni todos los vértices
 correspondientes a incógnitas para obtener los que poseen una sola arista
 adyacente de color rojo podemos mejorar la complejidad temporal.
\end_layout

\begin_layout Standard
Una versión de este algoritmo modificada para ejecutarse en tiempo logarítmico
 se implementó como parte de la etapa de causalización.
 Esta implementación se hizo en el método 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+simpleCausalizationStrategy+
\end_layout

\end_inset

 de la clase 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+CausalizationStrategy+
\end_layout

\end_inset

.
 La misma se encuentra declarada en el archivo causalize/causalization_strategy.h
 e implementada en el archivo causalize/causalization_strategy.cpp.
\end_layout

\begin_layout Standard
La versión implementada del algoritmo no utiliza aristas coloreadas, en
 cambio, la condición para causalizar un par ecuación-incógnita es que el
 vértice posea una sola arista adyacente.
 Además una vez que se causalizó un par ecuación-incógnita se borran ambos
 vértices del grafo junto con las aristas adyacentes a ambos.
\end_layout

\begin_layout Standard
Este algoritmo se ejecuta previo a la ejecución de la función 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+apply_Tarjan+
\end_layout

\end_inset

.
 Para los modelos que no contienen bucles algebraicos el algoritmo logra
 causalizar todas las ecuaciones sin la necesidad de ejecutar la función
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+apply_Tarjan+
\end_layout

\end_inset

.
 Para los modelos que si poseen bucles algebraicos el algoritmo, de complejidad
 temporal lineal, reduce significativamente la cantidad de vértices y aristas
 del grafo haciendo más eficiente la ejecución de la función 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+apply_Tarjan+
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
A continuación vemos el código de la función 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+simpleCausalizationStrategy+
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}
\end_layout

\begin_layout Plain Layout

  void CausalizationStrategy::simpleCausalizationStrategy() { 
\end_layout

\begin_layout Plain Layout

    std::list<Vertex> eqDegree1Verts;
\end_layout

\begin_layout Plain Layout

    std::list<Vertex> unknownDegree1Verts;
\end_layout

\begin_layout Plain Layout

    CausalizationGraph::vertex_iterator vi, vi_end;
\end_layout

\begin_layout Plain Layout

    for(boost::tie(vi,vi_end) = vertices(_graph); vi != vi_end; ++vi) {
\end_layout

\begin_layout Plain Layout

	    Vertex v = *vi;
\end_layout

\begin_layout Plain Layout

	    if (out_degree(v, _graph) == 1 && !_graph[v].visited) {
\end_layout

\begin_layout Plain Layout

			Edge e = getUniqueEdge(v);
\end_layout

\begin_layout Plain Layout

			Vertex adjacent = target(e, _graph);
\end_layout

\begin_layout Plain Layout

			_graph[adjacent].visited = true;
\end_layout

\begin_layout Plain Layout

		    if (_graph[v].type == E) {
\end_layout

\begin_layout Plain Layout

			    eqDegree1Verts.push_back(v);
\end_layout

\begin_layout Plain Layout

  		  } else {
\end_layout

\begin_layout Plain Layout

	  		  unknownDegree1Verts.push_back(v);
\end_layout

\begin_layout Plain Layout

		    }
\end_layout

\begin_layout Plain Layout

  	  }
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    while(!eqDegree1Verts.empty() || !unknownDegree1Verts.empty()) {
\end_layout

\begin_layout Plain Layout

        std::list<Vertex>::iterator eqIter = eqDegree1Verts.begin();
\end_layout

\begin_layout Plain Layout

        if (eqIter != eqDegree1Verts.end()) {
\end_layout

\begin_layout Plain Layout

            Vertex eq = *eqIter;
\end_layout

\begin_layout Plain Layout

            Edge e = getUniqueEdge(eq);
\end_layout

\begin_layout Plain Layout

			Vertex unknown = target(e, _graph);
\end_layout

\begin_layout Plain Layout

			makeCausalBegining(_graph[eq].eqs, _graph[unknown].unknowns);
\end_layout

\begin_layout Plain Layout

			remove_edge(e, _graph);
\end_layout

\begin_layout Plain Layout

			remove_vertex(eq,_graph);
\end_layout

\begin_layout Plain Layout

			collectDegree1Verts(unknown, eqDegree1Verts);
\end_layout

\begin_layout Plain Layout

            remove_vertex(unknown,_graph);
\end_layout

\begin_layout Plain Layout

            eqDegree1Verts.erase(eqIter);
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

        std::list<Vertex>::iterator unknownIter = unknownDegree1Verts.begin();
\end_layout

\begin_layout Plain Layout

        if(unknownIter != unknownDegree1Verts.end()) {
\end_layout

\begin_layout Plain Layout

        	Vertex unknown = *unknownIter;
\end_layout

\begin_layout Plain Layout

            Edge e = getUniqueEdge(unknown); 
\end_layout

\begin_layout Plain Layout

            Vertex eq = target(e, _graph);
\end_layout

\begin_layout Plain Layout

            makeCausalEnd(_graph[eq].eq, _graph[unknown].unknown);
\end_layout

\begin_layout Plain Layout

            remove_edge(e, _graph);
\end_layout

\begin_layout Plain Layout

            remove_vertex(unknown, _graph);
\end_layout

\begin_layout Plain Layout

            collectDegree1Verts(eq, unknownDegree1Verts);
\end_layout

\begin_layout Plain Layout

       	 remove_vertex(eq, _graph);
\end_layout

\begin_layout Plain Layout

        	unknownDegree1Verts.erase(unknownIter);
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Al inicio de la función 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+simpleCausalizationStrategy+
\end_layout

\end_inset

 se declaran dos listas, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+eqDegree1Verts+
\end_layout

\end_inset

 y 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+unknownDegree1Verts+
\end_layout

\end_inset

.
 Estas listas contienen los vértices de grado uno asociados a ecuaciones
 en el primer caso y a incógnitas en el segundo.
\end_layout

\begin_layout Standard
La inicialización de las listas 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+eqDegree1Verts+
\end_layout

\end_inset

 y 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+unknownDegree1Verts+
\end_layout

\end_inset

 la hacemos iterando sobre los vértices del grafo de causalización (el primer
 bucle for), representado por el objeto 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+_graph+
\end_layout

\end_inset

 y buscando los vértices de grado uno que aún no hayan sido visitados.
 Cuando encontramos uno lo primero que hacemos es marcar el vértice adyacente
 como visitado ya que ambos serán causalizados en el mismo momento, luego
 agregamos el vértice a la lista correspondiente.
\end_layout

\begin_layout Standard
Luego de la inicialización de las listas que contienen los vértices de grado
 uno, lo que hacemos es extraer uno a uno los vértices de cada una de las
 listas y causalizarlos.
 Esto lo hacemos con un bucle while que itera hasta que ambas listas queden
 vacías.
 Para cada vértice de grado uno extraído de la lista 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+eqDegree1Verts+
\end_layout

\end_inset

 lo primero que hacemos es causalizarlo mediante la función 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+makeCausalBegining+
\end_layout

\end_inset

.
 Luego eliminamos del grafo la única arista incidente en el vértice y el
 vértice mismo.
 El vértice adyacente al vértice eliminado también debe ser removido, pero
 antes, es necesario colectar, entre los vértices adyacentes a este, los
 que sean de grado uno.
 La función 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+collectDegree1Verts+
\end_layout

\end_inset

 es la encargada de realizar esta tarea.
 Los vértices extraidos de la lista 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+unknownDegree1Verts+
\end_layout

\end_inset

 son causalizados mediante la función 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+makeCausalEnd+
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
A continuación vemos el código de las funciones 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+makeCausalBegining+
\end_layout

\end_inset

 y 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+makeCausalEnd+
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}
\end_layout

\begin_layout Plain Layout

  void CausalizationStrategy::makeCausalBegining(Equation e, Expression
 unknown) {
\end_layout

\begin_layout Plain Layout

    EquationList causalEqs = EquationSolver::solve(EquationList(1, e), ExpList(1
, unknown), _mmo_class.syms_ref(), c_code, _cl);
\end_layout

\begin_layout Plain Layout

    foreach_(Equation e, causalEqs) {
\end_layout

\begin_layout Plain Layout

      _causalEqsBegining.push_back(e);
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}
\end_layout

\begin_layout Plain Layout

  void CausalizationStrategy::makeCausalEnd(Equation e, Expression unknown)
 {
\end_layout

\begin_layout Plain Layout

    EquationList causalEqs = EquationSolver::solve(EquationList(1, e), ExpList(1
, unknown), _mmo_class.syms_ref(), c_code, _cl);
\end_layout

\begin_layout Plain Layout

    foreach_(Equation e, causalEqs) {
\end_layout

\begin_layout Plain Layout

      _causalEqsEnd[_causalEqsEndIndex--] = e;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Ambas funciones reciben como parámetro una ecuación y una incógnita.
 Lo primero que se hace es despejar la incógnita en la ecuación.
 El despeje lo realiza la función 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+EquationSolver::solve+
\end_layout

\end_inset


\begin_inset Foot
status open

\begin_layout Plain Layout
En los casos en los que el despeje mediante manipulación simbólica no es
 posible, como es el caso de ciertos lazos algebricos, la tarea se delega
 en el componente de simulación el cual aplicara técnicas de integración
 numérica para la resolución del sistema en cuestion.
\end_layout

\end_inset

 la cual fue implementada utilizando la biblioteca de manipulación simbólica
 GiNaC 
\begin_inset CommandInset citation
LatexCommand citep
key "bauer2002introduction"

\end_inset

.
 La ecuación, reordenada de manera que del lado izquierdo quede solo la
 incógnita, se agrega a la lista 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+_causalEqsBegining+
\end_layout

\end_inset

 en el caso de la función 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+makeCausalBegining+
\end_layout

\end_inset

 y al vector 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+_causalEqsEnd+
\end_layout

\end_inset

 en el caso de la función 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+makeCausalEnd+
\end_layout

\end_inset

.
 La lista 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+_causalEqsBegining+
\end_layout

\end_inset

 y el vector 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+_causalEqsEnd+
\end_layout

\end_inset

 se utilizaron como alternativa a la numeración de las ecuaciones planteada
 en la versión original del algoritmo simple.
\end_layout

\begin_layout Standard
Por último, tenemos el código de la función 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+collectDegree1Verts+
\end_layout

\end_inset

 la cual, dado un vértice, itera sobre las aristas incidentes.
 Por cada arista se obtiene el vértice adyacente, se elimina la arista del
 grafo y si el vértice adyacente es de grado uno se lo agrega a la lista
 correspondiente (
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+eqDegree1Verts+
\end_layout

\end_inset

 o 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+unknownDegree1Verts+
\end_layout

\end_inset

).
 De la misma manera que se hizo durante la inicialización de las listas
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+eqDegree1Verts+
\end_layout

\end_inset

 y 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+unknownDegree1Verts+
\end_layout

\end_inset

, por cada vértice de grado uno que encontramos marcamos el vértice adyacente
 como visitado ya que ambos se causalizan en el mismo momento.
 La eliminación de las aristas es una alternativa a colorearlas de color
 azul que es lo que se plantea en la versión original del algoritmo.
 Al eliminar las aristas reducimos el tamaño del grafo lo cual resulta convenien
te en caso de que el algoritmo simple no logre causalizar todas las ecuaciones
 y sea necesario aplicar el algoritmo de Tarjan.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}
\end_layout

\begin_layout Plain Layout

  void CausalizationStrategy::collectDegree1Verts(Vertex v, std::list<Vertex>
 &degree1Verts) {
\end_layout

\begin_layout Plain Layout

    CausalizationGraph::out_edge_iterator outEdgeIter, outEdgeIterEnd, next;
\end_layout

\begin_layout Plain Layout

    boost::tie(outEdgeIter, outEdgeIterEnd) = out_edges(v, _graph);
\end_layout

\begin_layout Plain Layout

    for(next = outEdgeIter; outEdgeIter != outEdgeIterEnd; outEdgeIter =
 next) {
\end_layout

\begin_layout Plain Layout

      next++;
\end_layout

\begin_layout Plain Layout

      Edge adjEdge = *outEdgeIter;
\end_layout

\begin_layout Plain Layout

      Vertex adjacent = target(adjEdge, _graph);
\end_layout

\begin_layout Plain Layout

      remove_edge(adjEdge, _graph);
\end_layout

\begin_layout Plain Layout

      if (out_degree(adjacent, _graph) == 1 && !_graph[adjacent].visited)
 {
\end_layout

\begin_layout Plain Layout

        Edge e = getUniqueEdge(adjacent);
\end_layout

\begin_layout Plain Layout

        Vertex adjAdjacent = target(e, _graph);
\end_layout

\begin_layout Plain Layout

        _graph[adjAdjacent].visited = true;
\end_layout

\begin_layout Plain Layout

        degree1Verts.push_back(adjacent);
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Aplicación del algoritmo simple optimizado sobre un grafo de ejemplo
\end_layout

\begin_layout Standard
Para clarificar el algoritmo implementado en la función 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+simpleCausalizationStrategy+
\end_layout

\end_inset

 vamos a utililizar el mismo grafo de ejemplo que utilizamos en la sección
 anterior (figura 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:alg_simple_step_by_step}
\end_layout

\end_inset

).
 La figura 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:ej_alg_simple_op_1}
\end_layout

\end_inset

 muestra el estado incial del grafo junto con el estado de las listas 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+eqDegree1Verts+
\end_layout

\end_inset

 y 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+unknownDegree1Verts+
\end_layout

\end_inset

 luego de haber sido inicializadas.
 Durante la incialización se encontraron dos vértices de grado 1.
 El primero es un vértice asociado a una ecuación por eso fue insertado
 en la lista 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+eqDegree1Verts+
\end_layout

\end_inset

.
 El segundo vértice esta asociado a una incógnita y por lo tanto fue insertado
 en la lista 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+unknownDegree1Verts+
\end_layout

\end_inset

.
 En la figura también incluimos el estado de las listas 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+_causalEqsBegining+
\end_layout

\end_inset

 y 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+_causalEqsEnd+
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
La primer iteración del bucle 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+while+
\end_layout

\end_inset

 (presente en la función 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+simpleCausalizationStrategy+
\end_layout

\end_inset

) la dividimos en dos etapas.
 La primer etapa es la que consume y procesa el contenido de la lista 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+eqDegree1Verts+
\end_layout

\end_inset

.
 El resultado de esta etapa se puede ver en la figura 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:ej_alg_simple_op_2}
\end_layout

\end_inset

, el vértice 
\begin_inset Formula $h{}_{2}$
\end_inset

 junto con su única arista adjacente han sido eliminados del grafo.
 El vértice 
\begin_inset Formula $z{}_{2}$
\end_inset

 también fue eliminado pero previamente se identifico, entre los vértices
 adyacentes a este, los de grado 1.
 Este es el caso del vértice 
\begin_inset Formula $h{}_{3}$
\end_inset

 el cual ha sido agregado a la lista 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+eqDegree1Verts+
\end_layout

\end_inset

.
 Finalmente vemos que la ecuación 
\begin_inset Formula $z{}_{2}$
\end_inset

 a sido agregada a la lista 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+_causalEqsBegining+
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
El resultado de la segunda etapa de la primer iteración del bucle 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+while+
\end_layout

\end_inset

 lo vemos en la figura 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:ej_alg_simple_op_3}
\end_layout

\end_inset

, en la misma se puede ver que se han eliminado los vértices 
\begin_inset Formula $z{}_{3}$
\end_inset

 y 
\begin_inset Formula $h{}_{1}$
\end_inset

 junto con sus aristas adyacentes.
 La ecuación 
\begin_inset Formula $h{}_{1}$
\end_inset

 ha sido agregada a la lista 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+unknownDegree1Verts+
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Finalmente en la figura 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:ej_alg_simple_op_4}
\end_layout

\end_inset

 se puede ver que las listas 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+eqDegree1Verts+
\end_layout

\end_inset

 y 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+unknownDegree1Verts+
\end_layout

\end_inset

 han quedado vacias y por lo tanto el algoritmo concluye la ejecución.
 Concatenando las listas 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+_causalEqsBegining+
\end_layout

\end_inset

 y 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+_causalEqsEnd+
\end_layout

\end_inset

 obtenemos el mismo orden que habíamos logrado con la versión original del
 algoritmo simple.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{figure}[H]
\end_layout

\begin_layout Plain Layout

    
\backslash
centering
\end_layout

\begin_layout Plain Layout

    
\backslash
begin{subfigure}[b]{0.4
\backslash
textwidth}
\end_layout

\begin_layout Plain Layout

    
\backslash
includegraphics[width=0.8
\backslash
textwidth]{graphics/revision/ej_alg_simple_op_1.png}
\end_layout

\begin_layout Plain Layout

    
\backslash
caption{
\backslash
label{fig:ej_alg_simple_op_1}}
\end_layout

\begin_layout Plain Layout

  
\backslash
end{subfigure}
\end_layout

\begin_layout Plain Layout

  
\backslash
begin{subfigure}[b]{0.4
\backslash
textwidth}
\end_layout

\begin_layout Plain Layout

    
\backslash
includegraphics[width=0.8
\backslash
textwidth]{graphics/revision/ej_alg_simple_op_2.png}
\end_layout

\begin_layout Plain Layout

    
\backslash
caption{
\backslash
label{fig:ej_alg_simple_op_2}}
\end_layout

\begin_layout Plain Layout

  
\backslash
end{subfigure}
\end_layout

\begin_layout Plain Layout

  
\backslash
begin{subfigure}[b]{0.4
\backslash
textwidth}
\end_layout

\begin_layout Plain Layout

    
\backslash
includegraphics[width=0.8
\backslash
textwidth]{graphics/revision/ej_alg_simple_op_3.png}
\end_layout

\begin_layout Plain Layout

    
\backslash
caption{
\backslash
label{fig:ej_alg_simple_op_3}}
\end_layout

\begin_layout Plain Layout

  
\backslash
end{subfigure}
\end_layout

\begin_layout Plain Layout

 
\backslash
begin{subfigure}[b]{0.4
\backslash
textwidth}
\end_layout

\begin_layout Plain Layout

    
\backslash
centering
\end_layout

\begin_layout Plain Layout

    
\backslash
includegraphics[width=0.4
\backslash
textwidth]{graphics/revision/ej_alg_simple_op_4.png}
\end_layout

\begin_layout Plain Layout

    
\backslash
caption{
\backslash
label{fig:ej_alg_simple_op_4}}
\end_layout

\begin_layout Plain Layout

  
\backslash
end{subfigure}
\end_layout

\begin_layout Plain Layout

  
\backslash
caption{
\backslash
label{fig:ej_alg_simple_op_step_by_step}}
\end_layout

\begin_layout Plain Layout


\backslash
end{figure}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Complejidad
\end_layout

\begin_layout Standard
Para calcular la complejidad de la función 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+simpleCausalizationStrategy+
\end_layout

\end_inset

 lo que vamos a hacer es calcular primero la complejidad de las subrutinas
 que esta función invoca.
 Luego a partir de esos valores calculados, y junto con los valores de complejid
ad temporal del resto de las funciones que se invocan, calcularemos la complejid
ad total de la función 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+simpleCausalizationStrategy+
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
A continuación se puede ver el cálculo de complejidad de las funciones 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+makeCausalBegining+
\end_layout

\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+makeCausalEnd+
\end_layout

\end_inset

 y 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+collectDegree1Verts+
\end_layout

\end_inset

.
 Notar que en el cálculo de complejidad no se consideró el costo del despeje
 de variables mediante la función 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+EquationSolver::solve+
\end_layout

\end_inset

.
 Esto es así porque para poder comparar el algoritmo simple con la aplicación
 del algoritmo de Tarjan (que implica el cálculo del matching), solo debemos
 considerar la parte del algoritmo que selecciona los pares ecuación-incógnita
 y que realiza la ordenación vertical de las ecuaciones.
\end_layout

\begin_layout Standard
\paragraph_spacing onehalf
\begin_inset Tabular
<lyxtabular version="3" rows="12" columns="5">
<features rotate="0" tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Función
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Complejidad
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Cantidad de invocaciones
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Complejidad total
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
makeCausalBegining
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
push_back (std::list)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $O(1)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $1$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $O(1)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $O(1)$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
makeCausalEnd
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
operator[] (std::vector)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $O(1)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $1$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $O(1)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $O(1)$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
collectDegree1Verts
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
target (Boost Graph)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $O(1)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $2$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $O(1)$
\end_inset


\end_layout

\end_inset
</cell>
<cell multirow="3" alignment="center" valignment="middle" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $O(\log V)$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
remove_edge (Boost Graph)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $O(K)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $1$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $O(K)$
\end_inset


\end_layout

\end_inset
</cell>
<cell multirow="4" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
out_degree (Boost Graph)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $O(K)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $1$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $O(K)$
\end_inset


\end_layout

\end_inset
</cell>
<cell multirow="4" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
getUniqueEdge
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $O(1)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $1$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $O(1)$
\end_inset


\end_layout

\end_inset
</cell>
<cell multirow="4" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
push_back (std::list)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $O(1)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $1$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $O(1)$
\end_inset


\end_layout

\end_inset
</cell>
<cell multirow="4" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
operator[] (CausalizationGraph)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $O(\log V)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $2$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $O(\log V)$
\end_inset


\end_layout

\end_inset
</cell>
<cell multirow="4" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\paragraph_spacing onehalf
Habiendo calculado la complejidad de las subrutinas ahora si podemos calcular
 la complejidad de la función 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+simpleCausalizationStrategy+
\end_layout

\end_inset

.
 En la siguiente tabla se detalla el cálculo.
\end_layout

\begin_layout Standard
\paragraph_spacing onehalf
\begin_inset Tabular
<lyxtabular version="3" rows="17" columns="5">
<features rotate="0" tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Función
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Complejidad
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Cantidad invocaciones
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Complejidad total
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Inicialización de las listas eqDegree1Verts y unknownDegree1Verts
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
vertices (Boost Graph)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $O(1)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $1$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $O(1)$
\end_inset


\end_layout

\end_inset
</cell>
<cell multirow="3" alignment="center" valignment="middle" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $O(V\log V)$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
out_degree (Boost Graph)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $O(K)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $V$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $O(V)$
\end_inset


\end_layout

\end_inset
</cell>
<cell multirow="4" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
graph[] (Boost Graph)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $O(\log V)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $3V$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $O(V\log V)$
\end_inset


\end_layout

\end_inset
</cell>
<cell multirow="4" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
getUniqueEdge
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $O(1)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $V$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $O(V)$
\end_inset


\end_layout

\end_inset
</cell>
<cell multirow="4" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
target (Boost Graph)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $O(1)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $V$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $O(V)$
\end_inset


\end_layout

\end_inset
</cell>
<cell multirow="4" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
push_back (std::list)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $O(1)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $V$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $O(V)$
\end_inset


\end_layout

\end_inset
</cell>
<cell multirow="4" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Bucle while
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
out_degree
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $O(K)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $V+KV$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $O(V)$
\end_inset


\end_layout

\end_inset
</cell>
<cell multirow="3" alignment="center" valignment="middle" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $O(V\log V)$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
push_back
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $O(1)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $2V$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $O(V)$
\end_inset


\end_layout

\end_inset
</cell>
<cell multirow="4" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
graph[]
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $O(\log V)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $V+2KV$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $O(V\log V)$
\end_inset


\end_layout

\end_inset
</cell>
<cell multirow="4" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
remove_vertex
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $O(1)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $2V$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $O(V)$
\end_inset


\end_layout

\end_inset
</cell>
<cell multirow="4" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
remove_edge
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $O(K)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $V+KV$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $O(V)$
\end_inset


\end_layout

\end_inset
</cell>
<cell multirow="4" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
makeCausalBegining
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $O(1)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $V$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $O(V)$
\end_inset


\end_layout

\end_inset
</cell>
<cell multirow="4" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
makeCausalEnd
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $O(1)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $V$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $O(V$
\end_inset

)
\end_layout

\end_inset
</cell>
<cell multirow="4" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
collectDegree1Verts
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $O(\log V)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $V$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $O(V\log V)$
\end_inset


\end_layout

\end_inset
</cell>
<cell multirow="4" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
A partir de los valores calculados en la tabla se puede concluir que la
 complejidad temporal de la función 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+simpleCausalizationStrategy+
\end_layout

\end_inset

 es 
\begin_inset Formula $O(V\log V)$
\end_inset

.
 Vemos aquí que la complejidad de esta nueva versión es mejor que la obtenida
 al aplicar Tarjan directamente (que era cuadrática).
\end_layout

\begin_layout Standard
En el capítulo 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Prueba-de-eficiencia"

\end_inset

 realizamos una comparación de los tiempos de ejecución resultantes de aplicar
 el algoritmo simple y el algoritmo de Tarjan sobre un modelo de ejemplo.
\end_layout

\begin_layout Chapter
\begin_inset CommandInset label
LatexCommand label
name "chap:Ejemplos"

\end_inset

Ejemplos
\end_layout

\begin_layout Standard
En este breve capítulo mostramos el resultado de aplicar el proceso de causaliza
ción sobre el modelo de un sistema muy conocido en el área de la ingeniería
 eléctrica, los circuitos RLC.
\end_layout

\begin_layout Section
Circuito eléctrico RLC
\end_layout

\begin_layout Standard
A continuación vemos el diagrama correspondiente a un circuito eléctrico
 RLC convencional.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{figure}[h]
\end_layout

\begin_layout Plain Layout

  
\backslash
centering
\end_layout

\begin_layout Plain Layout

  
\backslash
includegraphics[width=0.5
\backslash
textwidth]{graphics/rlc.png}
\end_layout

\begin_layout Plain Layout

  
\backslash
caption{RLC}
\end_layout

\begin_layout Plain Layout

  
\backslash
label{fig:RLC}
\end_layout

\begin_layout Plain Layout


\backslash
end{figure}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Dado que en el circuito hay cinco elementos, y cada uno define dos variables,
 denominadas la tensión y la intensidad de corriente a través de dicho elemento,
 necesitamos diez ecuaciones para describir el modelo, p.
 ej.
 las cinco ecuaciones correspondientes a cada elemento, las cuales definen
 la relación entre la tensión y la intensidad de corriente a través del
 elemento, más tres ecuaciones de malla en el voltaje de malla, más dos
 ecuaciones de nodos en la corriente del nodo.
 Un posible conjunto de ecuaciones es el siguiente:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray*}
u_{0} & = & f\left(t\right)\\
u_{1} & = & R_{1}i_{1}\\
u_{2} & = & R_{2}i_{2}\\
u_{L} & = & L\frac{du_{C}}{dt}\\
i_{C} & = & C\frac{du_{C}}{dt}\\
u_{0} & = & u_{1}+u_{2}\\
u_{L} & = & u_{1}+u_{2}\\
u_{C} & = & u_{2}\\
i_{0} & = & i_{1}+i_{L}\\
i_{1} & = & i_{2}+i_{C}
\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Standard
El modelo Modelica correspondiente a este sistema de ecuaciones se puede
 ver a continuación.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}[language=Modelica]
\end_layout

\begin_layout Plain Layout

  model RLC
\end_layout

\begin_layout Plain Layout

    Real u2;
\end_layout

\begin_layout Plain Layout

    Real u1;
\end_layout

\begin_layout Plain Layout

    Real uL;
\end_layout

\begin_layout Plain Layout

    Real iC;
\end_layout

\begin_layout Plain Layout

    Real i2;
\end_layout

\begin_layout Plain Layout

    Real u0;
\end_layout

\begin_layout Plain Layout

    Real i0;
\end_layout

\begin_layout Plain Layout

    Real i1;
\end_layout

\begin_layout Plain Layout

    Real iL;
\end_layout

\begin_layout Plain Layout

    Real uC;
\end_layout

\begin_layout Plain Layout

    parameter Real R1;
\end_layout

\begin_layout Plain Layout

    parameter Real R2;
\end_layout

\begin_layout Plain Layout

    parameter Real L;
\end_layout

\begin_layout Plain Layout

    parameter Real C;
\end_layout

\begin_layout Plain Layout

    equation
\end_layout

\begin_layout Plain Layout

      u0 = sin(12);
\end_layout

\begin_layout Plain Layout

      u1 = R1 * i1;
\end_layout

\begin_layout Plain Layout

      u2 = R2 * i2;
\end_layout

\begin_layout Plain Layout

      uL = L * der(iL);
\end_layout

\begin_layout Plain Layout

      iC = C *der(uC);
\end_layout

\begin_layout Plain Layout

      u0 = u1 + uC;
\end_layout

\begin_layout Plain Layout

      uL = u1 + u2;
\end_layout

\begin_layout Plain Layout

      uC = u2;
\end_layout

\begin_layout Plain Layout

      i0 = i1 + iL;
\end_layout

\begin_layout Plain Layout

      i1 = i2 + iC;
\end_layout

\begin_layout Plain Layout

  end RLC;
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Al ejecutar el causalizador sobre el modelo obtenemos un nuevo modelo cuyas
 ecuaciones se encuentran ordenadas vertical y horizontalmente.
 El modelo resultante se puede ver a continuación.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}[language=Modelica]
\end_layout

\begin_layout Plain Layout

  model RLC
\end_layout

\begin_layout Plain Layout

    Real u2;
\end_layout

\begin_layout Plain Layout

    Real u1;
\end_layout

\begin_layout Plain Layout

    Real uL;
\end_layout

\begin_layout Plain Layout

    Real iC;
\end_layout

\begin_layout Plain Layout

    Real i2;
\end_layout

\begin_layout Plain Layout

    Real u0;
\end_layout

\begin_layout Plain Layout

    Real i0;
\end_layout

\begin_layout Plain Layout

    Real i1;
\end_layout

\begin_layout Plain Layout

    Real iL;
\end_layout

\begin_layout Plain Layout

    Real uC;
\end_layout

\begin_layout Plain Layout

    parameter Real R1;
\end_layout

\begin_layout Plain Layout

    parameter Real R2;
\end_layout

\begin_layout Plain Layout

    parameter Real L;
\end_layout

\begin_layout Plain Layout

    parameter Real C;
\end_layout

\begin_layout Plain Layout

    equation
\end_layout

\begin_layout Plain Layout

      u0 = sin(12);
\end_layout

\begin_layout Plain Layout

      u2 = uC;
\end_layout

\begin_layout Plain Layout

      u1 = (-uC)+u0;
\end_layout

\begin_layout Plain Layout

      i2 = u2*(1/(R2));
\end_layout

\begin_layout Plain Layout

      i1 = (1/(R1))*u1;
\end_layout

\begin_layout Plain Layout

      iC = (-i2)+i1;
\end_layout

\begin_layout Plain Layout

      uL = u1+u2;
\end_layout

\begin_layout Plain Layout

      der(uC) = iC*(1/(C));
\end_layout

\begin_layout Plain Layout

      der(iL) = (1/(L))*uL;
\end_layout

\begin_layout Plain Layout

      i0 = i1+iL;
\end_layout

\begin_layout Plain Layout

  end RLC; 
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
En el modelo resultante las ecuaciones están formadas por incógnitas del
 lado izquierdo y por expresiones formadas por variables conocidas del lado
 derecho.
\end_layout

\begin_layout Section
Circuito RLC con lazo algebraico
\end_layout

\begin_layout Standard
Si sustituimos el capacitor del ejemplo anterior por otra resistencia obtenemos
 el diagrama que se ve en la siguiente imagen.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{figure}[h]
\end_layout

\begin_layout Plain Layout

  
\backslash
centering
\end_layout

\begin_layout Plain Layout

  
\backslash
includegraphics[width=0.5
\backslash
textwidth]{graphics/rlc_loop.png}
\end_layout

\begin_layout Plain Layout

  
\backslash
caption{RLC con bucle}
\end_layout

\begin_layout Plain Layout

  
\backslash
label{fig:RLC_Loop}
\end_layout

\begin_layout Plain Layout


\backslash
end{figure}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
El sistema de ecuaciones que modela el comportamiento del circuito es el
 siguiente.
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray}
u_{0} & = & f\left(t\right)\\
u_{1} & = & R_{1}i_{1}\\
u_{2} & = & R_{2}i_{2}\\
u_{3} & = & R_{3}i_{3}\\
u_{L} & = & L\frac{di_{L}}{dt}\\
u_{0} & = & u_{1}+u_{3}\\
u_{L} & = & u_{1}+u_{2}\\
u_{3} & = & u_{2}\\
i_{0} & = & i_{1}+i_{L}\\
i_{1} & = & i_{2}+i_{3}
\end{eqnarray}

\end_inset


\end_layout

\begin_layout Standard
Este modelo posee un lazo algebraico, es decir un conjunto de ecuaciones
 mutuamente dependientes.
 Para ver fácilmente el bucle algebraico, mostramos el grafo asociado al
 sistema de ecuaciones.
 Los nodos de las ecuaciones e incógnitas pertenecientes al bucle aparecen
 destacados con un fondo gris.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{figure}[h]
\end_layout

\begin_layout Plain Layout

  
\backslash
centering
\end_layout

\begin_layout Plain Layout

  
\backslash
includegraphics[width=0.5
\backslash
textwidth]{graphics/rlc_loop_graph.png}
\end_layout

\begin_layout Plain Layout

  
\backslash
caption{Grafo circuito RLC}
\end_layout

\begin_layout Plain Layout

  
\backslash
label{fig:RLC}
\end_layout

\begin_layout Plain Layout


\backslash
end{figure}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
La traducción a Modelica de las ecuaciones que describen el circuito RLC
 queda como se puede apreciar a continuación.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}[language=Modelica]
\end_layout

\begin_layout Plain Layout

  model RLC
\end_layout

\begin_layout Plain Layout

    Real u2;
\end_layout

\begin_layout Plain Layout

    Real u1;
\end_layout

\begin_layout Plain Layout

    Real u3
\end_layout

\begin_layout Plain Layout

    Real uL;
\end_layout

\begin_layout Plain Layout

    Real u0;
\end_layout

\begin_layout Plain Layout

    Real i0;
\end_layout

\begin_layout Plain Layout

    Real i1;
\end_layout

\begin_layout Plain Layout

    Real i2;
\end_layout

\begin_layout Plain Layout

    Real i3;
\end_layout

\begin_layout Plain Layout

    Real iL;
\end_layout

\begin_layout Plain Layout

    parameter Real R1;
\end_layout

\begin_layout Plain Layout

    parameter Real R2;
\end_layout

\begin_layout Plain Layout

    parameter Real L;
\end_layout

\begin_layout Plain Layout

    equation
\end_layout

\begin_layout Plain Layout

      u0 = sin(12);
\end_layout

\begin_layout Plain Layout

      u1 = R1 * i1;
\end_layout

\begin_layout Plain Layout

      u2 = R2 * i2;
\end_layout

\begin_layout Plain Layout

      u3 = R3 * i3; 
\end_layout

\begin_layout Plain Layout

      uL = L * der(iL); 
\end_layout

\begin_layout Plain Layout

      u0 = u1 + u3; 
\end_layout

\begin_layout Plain Layout

      uL = u1 + u2;
\end_layout

\begin_layout Plain Layout

      u3 = u2;
\end_layout

\begin_layout Plain Layout

      i0 = i1 + iL;
\end_layout

\begin_layout Plain Layout

      i1 = i2 + i3;
\end_layout

\begin_layout Plain Layout

  end RLC;
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Al ejecutar el causalizador sobre el modelo obtenemos un nuevo modelo, cuyas
 ecuaciones se encuentran reordenadas de la siguiente manera.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}[language=Modelica]
\end_layout

\begin_layout Plain Layout

  model RLC
\end_layout

\begin_layout Plain Layout

    Real u2;
\end_layout

\begin_layout Plain Layout

    Real u1;
\end_layout

\begin_layout Plain Layout

    Real u3
\end_layout

\begin_layout Plain Layout

    Real uL;
\end_layout

\begin_layout Plain Layout

    Real u0;
\end_layout

\begin_layout Plain Layout

    Real i0;
\end_layout

\begin_layout Plain Layout

    Real i1;
\end_layout

\begin_layout Plain Layout

    Real i2;
\end_layout

\begin_layout Plain Layout

    Real i3;
\end_layout

\begin_layout Plain Layout

    Real iL;
\end_layout

\begin_layout Plain Layout

    parameter Real R1;
\end_layout

\begin_layout Plain Layout

    parameter Real R2;
\end_layout

\begin_layout Plain Layout

    parameter Real R3;
\end_layout

\begin_layout Plain Layout

    parameter Real L;
\end_layout

\begin_layout Plain Layout

    equation
\end_layout

\begin_layout Plain Layout

    u0 = sin(12);
\end_layout

\begin_layout Plain Layout

    i1 = (1/(R1*R2+R1*R3+R2*R3))*(u0*R3+u0*R2);
\end_layout

\begin_layout Plain Layout

    u2 = u0*(1/(R1*R2+R1*R3+R2*R3))*R2*R3;
\end_layout

\begin_layout Plain Layout

    i3 = u0*(1/(R1*R2+R1*R3+R2*R3))*R2;
\end_layout

\begin_layout Plain Layout

    u1 = (1/(R1*R2+R1*R3+R2*R3))*(u0*R1*R2+u0*R1*R3);
\end_layout

\begin_layout Plain Layout

    u3 = u0*(1/(R1*R2+R1*R3+R2*R3))*R2*R3;
\end_layout

\begin_layout Plain Layout

    i2 = u0*(1/(R1*R2+R1*R3+R2*R3))*R3;
\end_layout

\begin_layout Plain Layout

    uL = u1+u2;
\end_layout

\begin_layout Plain Layout

    der(iL) = (1/(L))*uL;
\end_layout

\begin_layout Plain Layout

    i0 = i1+iL;
\end_layout

\begin_layout Plain Layout

  end RLC;
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Al igual que con el caso de la sección anterior, el modelo resultante se
 encuentra ordenado vertical y horizontalmente.
 En este caso el bucle pudo ser resuelto (todos los lados derechos de las
 ecuaciones dependen solo de la variable 
\begin_inset Formula $u_{0}$
\end_inset

) porque las ecuaciones que lo conformaban eran lineales.
 Si ese no hubiese sido el caso lo que hubiésemos obtenido es un sistema
 ordenado donde el bucle se sustituye por una función externa como la que
 se ve a continuación.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}
\end_layout

\begin_layout Plain Layout

(u0,i1,u2,i3,u1,u3,i2) = fsolve(u0);
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Esta función externa resuelve el sistema de ecuaciones formado por las ecuacione
s del bucle mediante métodos de integración numérica.
\end_layout

\begin_layout Chapter
\begin_inset CommandInset label
LatexCommand label
name "chap:Prueba-de-eficiencia"

\end_inset

Prueba de eficiencia
\end_layout

\begin_layout Standard
En la sección 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Optimización"

\end_inset

 se presentó una optimización del proceso de causalización la cual consistió
 en incluir un algoritmo que combinado con el de Tarjan realiza la causalización
 de manera óptima.
\end_layout

\begin_layout Standard
Para medir los tiempos de ejecución de las diferentes estrategias armamos
 un test, el cual recibe como entrada un modelo Modelica y lo causaliza
 utilizando las tres estrategias anteriormente mencionadas.
 Al finalizar imprime el tiempo que demoro en ejecutarse cada estrategia.
 El test se encuentra implementado en el archivo test/causalize/performance_test.
cpp.
\end_layout

\begin_layout Section
Primer caso
\end_layout

\begin_layout Standard
Para realizar las puebas de eficiencia elegimos un modelo que representa
 al fenómino de transmisión de masa/energía en una dimensión.
 Este sistema resulta apropiado para la prueba de eficiencia porque, como
 vamos a ver cuando presentemos el modelos Modelica, podemos controlar el
 tamaño del mismo modificando un solo parámetro.
\end_layout

\begin_layout Standard
La ecuación que representa este fenómeno es la siguiente:
\end_layout

\begin_layout Standard
\align center
\begin_inset Formula $\frac{\partial u(x,t)}{\partial t}+a\frac{\partial u(x,t)}{\partial x}=d\frac{\partial^{2}u(x,t)}{\partial x^{2}}$
\end_inset


\end_layout

\begin_layout Standard
donde 
\begin_inset Formula $u(x,t)$
\end_inset

 representa la concentración de masa o energía en la coordenada espacial
 
\begin_inset Formula $x$
\end_inset

 en el tiempo 
\begin_inset Formula $t$
\end_inset

.
 
\end_layout

\begin_layout Standard
La ecuación presenta derivadas en función de la componente espacial, lo
 que la transforma en una ecuación en derivadas parciales.
 Ésta es convertida en una ecuación diferencial ordinaria utilizando el
 Método de Líneas 
\begin_inset CommandInset citation
LatexCommand citep
key "CK06"

\end_inset

 el cual discretiza la componente espacial usando diferencias finitas en
 
\begin_inset Formula $N$
\end_inset

 segmentos.
 Cuanto mayor sea 
\begin_inset Formula $N$
\end_inset

 mejor será la aproximación.
 Una vez discretizada la componente espacial obtenemos el siguiente conjunto
 de ODEs:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray*}
\dot{u}_{n}(t) & = & 0\\
\dot{u}_{1}(t) & = & \frac{u_{1}(t)-u_{2}(t)}{\frac{1}{N}}\\
\dot{u}_{i}(t) & = & \frac{u_{i+1}(t)-u_{i}(t)}{\frac{1}{N}}+\frac{u_{i-1}(t)-u_{i}(t)}{\frac{\gamma}{N}}\;
\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Standard
para 
\begin_inset Formula $i\epsilon[2:N-1]$
\end_inset

.
\end_layout

\begin_layout Standard
El modelo Modelica correspondiente tiene la siguiente forma.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}[language=Modelica]
\end_layout

\begin_layout Plain Layout

  model OneDHeatTransferTI_FD
\end_layout

\begin_layout Plain Layout

    parameter Real L = 0.2;
\end_layout

\begin_layout Plain Layout

    constant Integer N = 100;
\end_layout

\begin_layout Plain Layout

    parameter Real T0 = 273.15;
\end_layout

\begin_layout Plain Layout

    parameter Real TN = 330;
\end_layout

\begin_layout Plain Layout

    parameter Real cp = 910;
\end_layout

\begin_layout Plain Layout

    parameter Real lambda = 237;
\end_layout

\begin_layout Plain Layout

    parameter Real rho = 2712;
\end_layout

\begin_layout Plain Layout

    final parameter
\end_layout

\begin_layout Plain Layout

    Real dx = L / (N - 1);
\end_layout

\begin_layout Plain Layout

    Real T[N] ;
\end_layout

\begin_layout Plain Layout

    initial algorithm
\end_layout

\begin_layout Plain Layout

      for i in 1:N - 1 loop
\end_layout

\begin_layout Plain Layout

        T[i] := T0;
\end_layout

\begin_layout Plain Layout

      end for;
\end_layout

\begin_layout Plain Layout

      T[N] := TN;
\end_layout

\begin_layout Plain Layout

    equation
\end_layout

\begin_layout Plain Layout

      der(T[N]) = 0;
\end_layout

\begin_layout Plain Layout

      for i in 2:N - 1 loop
\end_layout

\begin_layout Plain Layout

        der(T[i]) = lambda * ((T[i + 1] - T[i]) / dx + ((-T[i]) + T[i -
 1]) / dx) / cp / rho / dx;
\end_layout

\begin_layout Plain Layout

      end for;
\end_layout

\begin_layout Plain Layout

      der(T[1]) = lambda * ((T[2] - T[1]) / dx) / cp / rho / dx;
\end_layout

\begin_layout Plain Layout

  end OneDHeatTransferTI_FD; 
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Al ejecutar el test de performance sobre el modelo obtenemos una salida
 como la que siguiente:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{figure}[H]
\end_layout

\begin_layout Plain Layout

  
\backslash
centering
\end_layout

\begin_layout Plain Layout

  
\backslash
verb+Simple strategy: 0.020906 Tarjan strategy: 0.021469 Full Causalization
 strategy: 0.020833+
\end_layout

\begin_layout Plain Layout


\backslash
end{figure}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
donde cada estrategia reporta (en segundos) el tiempo utilizado.
\end_layout

\begin_layout Standard
En el gráfico 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:OneDHeatTransfer}
\end_layout

\end_inset

 se puede ver el resultado de aplicar el test sobre modelos 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+OneDHeatTransferTI_FD+
\end_layout

\end_inset

 con diferentes tamaños de la constante 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+N+
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{figure}[h]
\end_layout

\begin_layout Plain Layout

  
\backslash
centering
\end_layout

\begin_layout Plain Layout

  
\backslash
includegraphics[width=0.8
\backslash
textwidth]{graphics/revision/OneDHeatTransfer.png}
\end_layout

\begin_layout Plain Layout

  
\backslash
caption{OneDHeatTransfer}
\end_layout

\begin_layout Plain Layout

  
\backslash
label{fig:OneDHeatTransfer}
\end_layout

\begin_layout Plain Layout


\backslash
end{figure}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Según los calculos realizados en la sección 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:ComplejidadTarjan1"

\end_inset

 la complejidad de la estrategia compleja es 
\begin_inset Formula $O(V^{2})$
\end_inset

.
 En el caso de la estrategía simple (ver sección 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Optimización"

\end_inset

), la complejidad temporal es 
\begin_inset Formula $O(V+V\times\log V)$
\end_inset

.
 En el gráfico 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:OneDHeatTransfer}
\end_layout

\end_inset

 se puede apreciar que el crecimiento del tiempo de ejecución en función
 de la cantidad de ecuaciones del sistema se condice con los valores de
 complejidad calculados.
 Respecto a la estrategía completa de causalización, lo que se puede ver
 en el gráfico es que la curva es similar a la de la estrategía simple.
 Esto es porque el modelo de ejemplo no posee lazos algebraicos y por lo
 tanto solo es necesario la aplicación de la estrategía simple.
\end_layout

\begin_layout Section
Segundo caso
\end_layout

\begin_layout Standard
Para analizar qué sucede con la estrategía completa en el caso en el que
 el modelo sí posee lazos algebraicos lo que hicimos fue agregar un lazo
 al ejemplo 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+OneDHeatTransferTI_FD+
\end_layout

\end_inset

.
 La modificación consistió en agregar el arreglo 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+U+
\end_layout

\end_inset

 junto con un conjunto de ecuaciones todas incluidas en un bucle algebraico.
 A continuación se puede ver el modelo modificado.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}[language=Modelica]
\end_layout

\begin_layout Plain Layout

  model OneDHeatTransferTI_FD
\end_layout

\begin_layout Plain Layout

    parameter Real L = 0.2;
\end_layout

\begin_layout Plain Layout

    constant Integer N = 100;
\end_layout

\begin_layout Plain Layout

    parameter Real T0 = 273.15;
\end_layout

\begin_layout Plain Layout

    parameter Real TN = 330;
\end_layout

\begin_layout Plain Layout

    parameter Real cp = 910;
\end_layout

\begin_layout Plain Layout

    parameter Real lambda = 237;
\end_layout

\begin_layout Plain Layout

    parameter Real rho = 2712;
\end_layout

\begin_layout Plain Layout

    final parameter
\end_layout

\begin_layout Plain Layout

    Real dx = L / (N - 1);
\end_layout

\begin_layout Plain Layout

    Real T[N];
\end_layout

\begin_layout Plain Layout

    Real U[N]; 
\end_layout

\begin_layout Plain Layout

    initial algorithm
\end_layout

\begin_layout Plain Layout

      for i in 1:N - 1 loop
\end_layout

\begin_layout Plain Layout

        T[i] := T0;
\end_layout

\begin_layout Plain Layout

      end for;
\end_layout

\begin_layout Plain Layout

      T[N] := TN;
\end_layout

\begin_layout Plain Layout

    equation
\end_layout

\begin_layout Plain Layout

      der(T[N]) = 0;
\end_layout

\begin_layout Plain Layout

      U[1]*U[2]=0;
\end_layout

\begin_layout Plain Layout

      for i in 2:N - 1 loop
\end_layout

\begin_layout Plain Layout

        der(T[i]) = der(T[i-1]) + lambda * ((T[i + 1] - T[i]) / dx + ((-T[i])
 + T[i - 1]) / dx) / cp / rho / dx;
\end_layout

\begin_layout Plain Layout

        U[i] = U[i+1]+U[i-1]; 
\end_layout

\begin_layout Plain Layout

      end for;
\end_layout

\begin_layout Plain Layout

      der(T[1]) = lambda * ((T[2] - T[1]) / dx) / cp / rho / dx;
\end_layout

\begin_layout Plain Layout

      U[N] = U[N-1]*2+sin(U[N]); 
\end_layout

\begin_layout Plain Layout

  end OneDHeatTransferTI_FD; 
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Al ejecutar el test sobre este nuevo modelo, para los mismos valores de
 la constante 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+N+
\end_layout

\end_inset

, obtenemos el gráfico 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:OneDHeatTransfer_loop}
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{figure}[h]
\end_layout

\begin_layout Plain Layout

  
\backslash
centering
\end_layout

\begin_layout Plain Layout

  
\backslash
includegraphics[width=0.8
\backslash
textwidth]{graphics/revision/OneDHeatTransfer_loop.png}
\end_layout

\begin_layout Plain Layout

  
\backslash
caption{OneDHeatTransfer con bucle algebraico}
\end_layout

\begin_layout Plain Layout

  
\backslash
label{fig:OneDHeatTransfer_loop}
\end_layout

\begin_layout Plain Layout


\backslash
end{figure}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
La línea punteada representa los tiempos de ejecución resultantes de aplicar
 solo el algoritmo de Tarjan.
 La línea semi-punteada representa los tiempos de ejecución de la estrategía
 de causalización completa, es decir ejecutando el algoritmo simple antes
 de aplicar Tarjan.
 La línea continua grafica los tiempos de la estrategía simple.
 Dada la existencia del bucle algebraico el algoritmo simple no termina
 por lo tanto no tiene sentido incluirlo (de manera aislada) en la comparación.
 La diferencia de crecimiento entre las curvas que representan la aplicación
 de Tarjan y la aplicación de la estrategía completa se condice con los
 resultados obtenidos en la sección 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Optimización"

\end_inset

 y permite ver más claramente cómo la inclusión del algoritmo simple constituye
 una optimización del proceso de causalización.
\end_layout

\begin_layout Chapter
\begin_inset CommandInset label
LatexCommand label
name "sec:Tests-unitarios"

\end_inset

Tests unitarios
\end_layout

\begin_layout Standard
Los tests unitarios se desarrollaron utilizando la biblioteca Boost Test
 
\begin_inset CommandInset citation
LatexCommand citep
key "ROTEST"

\end_inset

.
 Para cada componente que deseábamos testear escribimos un archivo diferente.
 Cada archivo se compone de un conjunto de funciones denotando cada una
 un unit test más una función que provee la biblioteca Boost Test, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+init_unit_test_suite+
\end_layout

\end_inset

, en la cual se listan los tests a ejecutar.
 Estos archivos luego se compilan en ejecutables.
 Al ejecutarlos se ejecutan los tests listados en la función 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+init_unit_test_suite+
\end_layout

\end_inset

.
 Las aserciones las realizamos utilizando la función 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+BOOST_CHECK+
\end_layout

\end_inset

.
 A modo ilustrativo vamos a ver una parte del archivo apply_Tarjan_test.cpp
 que corresponde al unit test de la función 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+apply_Tarjan+
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}
\end_layout

\begin_layout Plain Layout

#include <boost/test/unit_test.hpp>
\end_layout

\begin_layout Plain Layout

#include <boost/test/included/unit_test.hpp>
\end_layout

\begin_layout Plain Layout

#include <causalize/apply_Tarjan.h>
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

using namespace boost::unit_test;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

void apply_Tarjan_test() {
\end_layout

\begin_layout Plain Layout

   ...
\end_layout

\begin_layout Plain Layout

   BOOST_CHECK(apply_Tarjan(graph, components) == 4);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

test_suite* init_unit_test_suite( int, char* [] ) {
\end_layout

\begin_layout Plain Layout

    framework::master_test_suite().p_name.value = "Apply Tarjan";
\end_layout

\begin_layout Plain Layout

    framework::master_test_suite().add( BOOST_TEST_CASE( &apply_Tarjan_test
 ));
\end_layout

\begin_layout Plain Layout

    return 0;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
En esta porción de código podemos ver la función 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+apply_Tarjan_test()+
\end_layout

\end_inset

 la cual constituye el unit test.
 También podemos ver la declaración de la función donde se agrega el test
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+apply_Tarjan_test+
\end_layout

\end_inset

 al test suite.
 Al ejecutar el test la salida es la siguiente:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

    $ ./apply_Tarjan_test
\end_layout

\begin_layout Plain Layout

    Running 1 test case...
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    *** No errors detected 
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Escribimos unit tests para los siguientes componentes:
\end_layout

\begin_layout Itemize
La función process_for_equations (ver 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Expansión-de-ecuaciones"

\end_inset

).
\end_layout

\begin_layout Itemize
La función apply_Tarjan (ver 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Aplicación-Tarjan-Boost"

\end_inset

).
\end_layout

\begin_layout Itemize
La clase Causalization Strategy (ver 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Optimización"

\end_inset

).
\end_layout

\begin_layout Standard
A continuación vamos a describir cada uno de los unit tests.
\end_layout

\begin_layout Section
process_for_equation_test
\end_layout

\begin_layout Standard
Para probar la expansión de ecuaciones de tipo For-Equation decidimos armar
 diferentes modelos Modelica, cada uno capturando alguna de las alternativas
 que existen para escribir este tipo de ecuaciones.
 Luego escribimos un test unitario para cada uno de estos modelos.
 Los test verifican que la cantidad de ecuaciones generadas coincida con
 lo que se definió en el 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+for_index+
\end_layout

\end_inset

 (ver sección 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Expansión-de-ecuaciones"

\end_inset

) y que la instanciación y evaluación de cada ecuación sea la correcta.
\end_layout

\begin_layout Standard
Los diferentes modelos se pueden ver a continuación.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{figure}[H]
\end_layout

\begin_layout Plain Layout

  
\backslash
begin{subfigure}[b]{0.5
\backslash
textwidth}
\end_layout

\begin_layout Plain Layout

	  
\backslash
begin{lstlisting}[language=Modelica]
\end_layout

\begin_layout Plain Layout

	    model ForExample
\end_layout

\begin_layout Plain Layout

	      Real a[10];
\end_layout

\begin_layout Plain Layout

	    equation
\end_layout

\begin_layout Plain Layout

	      for i in 1:10 loop
\end_layout

\begin_layout Plain Layout

	        a[i] = i;
\end_layout

\begin_layout Plain Layout

	      end for;
\end_layout

\begin_layout Plain Layout

	    end ForExample;
\end_layout

\begin_layout Plain Layout

	  
\backslash
end{lstlisting}
\end_layout

\begin_layout Plain Layout

	  
\backslash
subcaption{
\backslash
label{fig:for_model_1}}
\end_layout

\begin_layout Plain Layout

  
\backslash
end{subfigure}
\end_layout

\begin_layout Plain Layout

  
\backslash
begin{subfigure}[b]{0.5
\backslash
textwidth}
\end_layout

\begin_layout Plain Layout

	  
\backslash
begin{lstlisting}[language=Modelica]
\end_layout

\begin_layout Plain Layout

	    model ForExample
\end_layout

\begin_layout Plain Layout

	      constant Integer N = 11;
\end_layout

\begin_layout Plain Layout

	      constant Integer S = 1;
\end_layout

\begin_layout Plain Layout

	      constant Integer M = 20;
\end_layout

\begin_layout Plain Layout

	      Real a[10];
\end_layout

\begin_layout Plain Layout

	    equation
\end_layout

\begin_layout Plain Layout

	      for i in N:S:M loop
\end_layout

\begin_layout Plain Layout

	        a[i] = i;
\end_layout

\begin_layout Plain Layout

	      end for;
\end_layout

\begin_layout Plain Layout

	    end ForExample;
\end_layout

\begin_layout Plain Layout

	  
\backslash
end{lstlisting}
\end_layout

\begin_layout Plain Layout

      
\backslash
subcaption{
\backslash
label{fig:for_model_2}}
\end_layout

\begin_layout Plain Layout

  
\backslash
end{subfigure}
\end_layout

\begin_layout Plain Layout

  
\backslash
begin{subfigure}[b]{0.5
\backslash
textwidth}
\end_layout

\begin_layout Plain Layout

	  
\backslash
begin{lstlisting}[language=Modelica]
\end_layout

\begin_layout Plain Layout

	    model ForExample
\end_layout

\begin_layout Plain Layout

	      Real a[10];
\end_layout

\begin_layout Plain Layout

	    equation
\end_layout

\begin_layout Plain Layout

	      for i in {1,2,3,4,5} loop 
\end_layout

\begin_layout Plain Layout

	          a[i] = i; 
\end_layout

\begin_layout Plain Layout

	      end for;
\end_layout

\begin_layout Plain Layout

	    end ForExample;
\end_layout

\begin_layout Plain Layout

	  
\backslash
end{lstlisting}
\end_layout

\begin_layout Plain Layout

  	
\backslash
subcaption{
\backslash
label{fig:for_model_3}}
\end_layout

\begin_layout Plain Layout

  
\backslash
end{subfigure}
\end_layout

\begin_layout Plain Layout

  
\backslash
begin{subfigure}[b]{0.5
\backslash
textwidth}
\end_layout

\begin_layout Plain Layout

	  
\backslash
begin{lstlisting}[language=Modelica]
\end_layout

\begin_layout Plain Layout

	    model ForExample
\end_layout

\begin_layout Plain Layout

	      Real a[10];
\end_layout

\begin_layout Plain Layout

	    equation
\end_layout

\begin_layout Plain Layout

	      for i in 1:10 loop
\end_layout

\begin_layout Plain Layout

	          a[i+1] = i+1; 
\end_layout

\begin_layout Plain Layout

	      end for;
\end_layout

\begin_layout Plain Layout

	    end ForExample;
\end_layout

\begin_layout Plain Layout

	  
\backslash
end{lstlisting}
\end_layout

\begin_layout Plain Layout

  	
\backslash
subcaption{
\backslash
label{fig:for_model_4}}
\end_layout

\begin_layout Plain Layout

  
\backslash
end{subfigure}
\end_layout

\begin_layout Plain Layout


\backslash
end{figure}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Los primeros tres modelos permiten verificar el procesamiento del 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+for_index+
\end_layout

\end_inset

 en sus diferentes variantes.
 El cuarto modelo permite verificar la evaluación de las expresiones resultantes
 de la instanciación del índice de iteración.
 En todos los modelos se verifica que la cantidad de ecuaciones generadas
 y la instanciación del índice en cada una sea la correcta.
\end_layout

\begin_layout Standard
A continuación vemos el código del unit test para el primer caso de prueba.
 Los otros tests, muy similares al que mostramos acá, se pueden encontrar
 en el archivo test/causalize/for_unrolling/process_for_equations_test.cpp.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}
\end_layout

\begin_layout Plain Layout

  void unrolling_test_1() {
\end_layout

\begin_layout Plain Layout

   bool r;
\end_layout

\begin_layout Plain Layout

    StoredDef sd=parseFile("for_example_1.mo",r);
\end_layout

\begin_layout Plain Layout

    if (!r) {
\end_layout

\begin_layout Plain Layout

      cout << "Couldn't open for_example.mo file" << endl;
\end_layout

\begin_layout Plain Layout

      return;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    Class ast_c = boost::get<Class>(sd.classes().front());
\end_layout

\begin_layout Plain Layout

    MMO_Class c(ast_c); 
\end_layout

\begin_layout Plain Layout

    int equationsBefore = c.equations().equations().size(); 
\end_layout

\begin_layout Plain Layout

    Causalize::process_for_equations(c);
\end_layout

\begin_layout Plain Layout

    int equationsAfter = c.equations().equations().size();
\end_layout

\begin_layout Plain Layout

    BOOST_CHECK(equationsAfter == 10);
\end_layout

\begin_layout Plain Layout

    int i=1;
\end_layout

\begin_layout Plain Layout

    foreach_(Equation eq, c.equations().equations()) {
\end_layout

\begin_layout Plain Layout

      BOOST_CHECK(is<Equality>(eq));
\end_layout

\begin_layout Plain Layout

      Equality eqEq = get<Equality>(eq);
\end_layout

\begin_layout Plain Layout

      Expression expLeft = eqEq.left();
\end_layout

\begin_layout Plain Layout

      BOOST_CHECK(is<Reference>(expLeft));
\end_layout

\begin_layout Plain Layout

      Reference array = get<Reference>(expLeft);
\end_layout

\begin_layout Plain Layout

      BOOST_CHECK(array.ref().size() == 1);
\end_layout

\begin_layout Plain Layout

      ExpList indexes = get<1>(array.ref().front());
\end_layout

\begin_layout Plain Layout

      BOOST_CHECK(indexes.size() == 1);
\end_layout

\begin_layout Plain Layout

      Expression index = indexes.front();
\end_layout

\begin_layout Plain Layout

      BOOST_CHECK((int)get<Modelica::AST::Integer>(index) == i);
\end_layout

\begin_layout Plain Layout

      Expression expRight = eqEq.right();
\end_layout

\begin_layout Plain Layout

      is<Integer>(expRight);
\end_layout

\begin_layout Plain Layout

      BOOST_CHECK(get<Integer>(expRight) == i);
\end_layout

\begin_layout Plain Layout

      i++;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
La primer aserción que aparece en el test es la que verfica que la cantidad
 de ecuaciones generadas sea la correcta, en nuestro caso el número correcto
 es 10.
 Luego se verifica que cada ecuación se haya generado correctamente.
 Primero se revisa que la variable del lado izquierdo de cada ecuación sea
 un arreglo unidimensional y que la instanciación del índice del arreglo
 sea la correcta.
 Luego se verifica que la expresión del lado derecho sea de tipo entero
 y que la instanciación y evaluación (en este caso trivial) de la misma
 sea que corresponde.
\end_layout

\begin_layout Section
apply_Tarjan_test
\end_layout

\begin_layout Standard
Para realizar el test de la función 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+apply_Tarjan+
\end_layout

\end_inset

, descripta en la sección 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Aplicación-Tarjan-Boost"

\end_inset

, construimos un grafo de causalización sencillo, al cual le 
\begin_inset Quotes eld
\end_inset

fabricamos
\begin_inset Quotes erd
\end_inset

 un bucle.
 El grafo que creamos es un grafo con 10 vértices y 11 aristas.
 La declaración del grafo se puede ver a continuación:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}
\end_layout

\begin_layout Plain Layout

  CausalizationGraph graph;
\end_layout

\begin_layout Plain Layout

  VertexProperties vp1;
\end_layout

\begin_layout Plain Layout

  vp1.type = E;
\end_layout

\begin_layout Plain Layout

  Vertex e1 = add_vertex(vp1, graph);
\end_layout

\begin_layout Plain Layout

  VertexProperties vp2;
\end_layout

\begin_layout Plain Layout

  vp2.type = U;
\end_layout

\begin_layout Plain Layout

  Vertex u1 = add_vertex(vp2, graph);
\end_layout

\begin_layout Plain Layout

  VertexProperties vp3;
\end_layout

\begin_layout Plain Layout

  vp3.type = E;
\end_layout

\begin_layout Plain Layout

  Vertex e2 = add_vertex(vp3, graph);
\end_layout

\begin_layout Plain Layout

  VertexProperties vp4;
\end_layout

\begin_layout Plain Layout

  vp4.type = U;
\end_layout

\begin_layout Plain Layout

  Vertex u2 = add_vertex(vp4, graph);
\end_layout

\begin_layout Plain Layout

  VertexProperties vp5;
\end_layout

\begin_layout Plain Layout

  vp5.type = E;
\end_layout

\begin_layout Plain Layout

  Vertex e3 = add_vertex(vp5, graph);
\end_layout

\begin_layout Plain Layout

  VertexProperties vp6;
\end_layout

\begin_layout Plain Layout

  vp6.type = U;
\end_layout

\begin_layout Plain Layout

  Vertex u3 = add_vertex(vp6, graph);
\end_layout

\begin_layout Plain Layout

  VertexProperties vp7;
\end_layout

\begin_layout Plain Layout

  vp7.type = E;
\end_layout

\begin_layout Plain Layout

  Vertex e4 = add_vertex(vp7, graph);
\end_layout

\begin_layout Plain Layout

  VertexProperties vp8;
\end_layout

\begin_layout Plain Layout

  vp8.type = U;
\end_layout

\begin_layout Plain Layout

  Vertex u4 = add_vertex(vp8, graph);
\end_layout

\begin_layout Plain Layout

  VertexProperties vp9;
\end_layout

\begin_layout Plain Layout

  vp9.type = E;
\end_layout

\begin_layout Plain Layout

  Vertex e5 = add_vertex(vp9, graph);
\end_layout

\begin_layout Plain Layout

  VertexProperties vp10;
\end_layout

\begin_layout Plain Layout

  vp10.type = U;
\end_layout

\begin_layout Plain Layout

  Vertex u5 = add_vertex(vp10, graph);
\end_layout

\begin_layout Plain Layout

  add_edge(e1, u3, graph);
\end_layout

\begin_layout Plain Layout

  add_edge(e1, u4, graph);
\end_layout

\begin_layout Plain Layout

  add_edge(e2, u2, graph);
\end_layout

\begin_layout Plain Layout

  add_edge(e3, u2, graph);
\end_layout

\begin_layout Plain Layout

  add_edge(e4, u1, graph);
\end_layout

\begin_layout Plain Layout

  add_edge(e4, u2, graph);
\end_layout

\begin_layout Plain Layout

  add_edge(e5, u1, graph);
\end_layout

\begin_layout Plain Layout

  // The following edges  form a cycle.
\end_layout

\begin_layout Plain Layout

  add_edge(e3, u3, graph);
\end_layout

\begin_layout Plain Layout

  add_edge(e3, u5, graph);
\end_layout

\begin_layout Plain Layout

  add_edge(e5, u3, graph);
\end_layout

\begin_layout Plain Layout

  add_edge(e5, u5, graph);
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Las últimas 4 aristas forman el único bucle del grafo.
\end_layout

\begin_layout Standard
El algoritmo de Tarjan se aplica sobre un grafo dirigido que resulta de
 aplicar los pasos descriptos en 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Aplicación-Tarjan-Boost"

\end_inset

 a un grafo no dirigido.
 Para el caso del grafo utilizado en este test el grafo dirigido resultante
 es un grafo de 5 vértices con un bucle.
 Por lo tanto el algoritmo de Tarjan debe encontrar 4 componentes fuertemente
 conexos.
 Esta aserción es la que utilizamos para probar nuestra función 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+apply_Tarjan+
\end_layout

\end_inset

 y lo hacemos de la siguiente manera:
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
FB: Faltan cosas acá
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}
\end_layout

\begin_layout Plain Layout

  std::map<int, causalize::Component> components;
\end_layout

\begin_layout Plain Layout

  BOOST_CHECK(apply_Tarjan(graph, components) == 4);
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Section
causalization_strategy_test
\end_layout

\begin_layout Standard
Este es el test asociado a la clase 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+CausalizationStrategy+
\end_layout

\end_inset

 (ver capítulo 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Implementación-etapa-de"

\end_inset

).
 El mismo permite validar que el modelo resultante de aplicar el método
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+CausalizationStrategy::causalize+
\end_layout

\end_inset

 es un modelo causal.
 Para validar la causalidad de un modelo escibimos la función 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+check_causality+
\end_layout

\end_inset

 la cual se puede encontrar en el archivo test/causalize/causalization_strategy_
test.cpp.
 La función recibe como parámetros el modelo a validar y la lista de incógnitas
 de dicho modelo.
 La validación se realiza ecuación por ecuación, verificando para cada una
 que la incógnita del lado izquierda pueda ser calculada a partir de las
 variables que aparecen del lado derecho.
 Dicho de otra manera lo que verificamos es que las variables que aparecen
 del lado derecho de cada ecuación sean variables conocidas (porque ya fueron
 calculadas por una ecuación anterior).
 El código de la función se puede ver a continuación.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}
\end_layout

\begin_layout Plain Layout

  void check_causality(MMO_Class &mmoClass, ExpList unknowns) {
\end_layout

\begin_layout Plain Layout

  const EquationList &causalEqs = mmoClass.equations_ref().equations_ref();
\end_layout

\begin_layout Plain Layout

  ExpList knowns;
\end_layout

\begin_layout Plain Layout

  foreach_(Equation equation, causalEqs) {
\end_layout

\begin_layout Plain Layout

    Equality eqEq = boost::get<Equality>(equation);
\end_layout

\begin_layout Plain Layout

    foreach_(Expression unknown, unknowns) {
\end_layout

\begin_layout Plain Layout

      Modelica::contains occurrs(unknown);
\end_layout

\begin_layout Plain Layout

      if (boost::apply_visitor(occurrs, eqEq.right_ref())) {
\end_layout

\begin_layout Plain Layout

        bool isKnown = false;
\end_layout

\begin_layout Plain Layout

        foreach_(Expression known, knowns) {
\end_layout

\begin_layout Plain Layout

          if(known == unknown) {
\end_layout

\begin_layout Plain Layout

            isKnown = true;
\end_layout

\begin_layout Plain Layout

          }
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

        BOOST_CHECK(isKnown);
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    Expression leftExpression = eqEq.left_ref();
\end_layout

\begin_layout Plain Layout

    if (is<Reference>(leftExpression)) {
\end_layout

\begin_layout Plain Layout

      knowns.push_back(leftExpression);
\end_layout

\begin_layout Plain Layout

    } else if (is<Call>(leftExpression)) {
\end_layout

\begin_layout Plain Layout

      Call call = boost::get<Call>(leftExpression);
\end_layout

\begin_layout Plain Layout

      if (call.name()=="der")
\end_layout

\begin_layout Plain Layout

        knowns.push_back(leftExpression);
\end_layout

\begin_layout Plain Layout

    } else if (is<Output>(leftExpression)) {
\end_layout

\begin_layout Plain Layout

      Output output = boost::get<Output>(leftExpression);
\end_layout

\begin_layout Plain Layout

      foreach_(OptExp oe, output.args()) {
\end_layout

\begin_layout Plain Layout

        if (oe)
\end_layout

\begin_layout Plain Layout

          knowns.push_back(oe.get());
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

    } else {
\end_layout

\begin_layout Plain Layout

      ERROR("Unexpected type for equation's left expression
\backslash
n");
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
La función declara una lista de variables conocidas.
 Luego itera sobre las ecuaciones del modelo que recibe como parámetro.
 Lo primero que hacemos para cada ecuación es validar que las variables
 que aparecen en el lado derecho de la ecuación se encuentren en la lista
 de variables conocidas.
 Esta lista se popula con las variables que aparecen en lado izquierdo de
 cada ecuación.
 Si el test se ejecuta satisfactoriamente es porque para cada ecuación,
 evaluada en el orden en el que se encuentra definida en el modelo, las
 variables del lado derecho son todas variables conocidas y de esta manera
 es posible resolver la ecuación y obtener el valor de la variable que se
 encuentra en el lado izquierdo.
\end_layout

\begin_layout Standard
Los casos de prueba que utilizamos fueron los presentados en el capítulo
 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Ejemplos"

\end_inset


\end_layout

\begin_layout Chapter
\begin_inset CommandInset label
LatexCommand label
name "chap:Conclusiones"

\end_inset

Conclusiones
\end_layout

\begin_layout Section
Conclusiones generales
\end_layout

\begin_layout Standard
En este trabajo se presentó la implementación en C++ de la etapa de causalizació
n de ecuaciones de un compilador Modelica.
 El trabajo estuvo enmarcado dentro del proyecto de investigación “Modelado,
 Simulación y Control en Tiempo Real con Aplicaciones en Electrónica de
 Potencia” de la Universidad Nacional de Rosario.
 Uno de los objectivos de dicho proyecto es el desarrollo de un compilador
 Modelica, denominado ModelicaCC (Modelica C Compiler), a partir del cual
 poder investigar distintos algoritmos en relación a modelos de gran escala.
 Puntualmente, la implementación aquí presentada de la etapa de causalización
 constituye el puntapié inicial para la implementación de un algoritmo de
 causalización vectorial, es decir, un algoritmo que realice la causalización
 de ecuaciones sin la necesidad de expandir los arreglos ni las estructuras
 repetitivas (como por ejmplo las For-Equation) presentes en el modelo.
 Dicha implementación se puede ver en el siguiente artículo 
\begin_inset CommandInset citation
LatexCommand citep
key "lsmodelica"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Note Comment
status open

\begin_layout Plain Layout
En la primer parte del trabajo se introdujo el lenguaje Modelica, así como
 también se introdujeron las nociones de ecuacion diferencial ordinaria
 y ecuación diferencial algebraica.
 Se planteó la necesidad de incluir en el proceso de compilación de un modelo
 Modelica, un componente capaz de transformar los modelos representados
 por ecuaciones diferenciales algebraicas en modelos equivalentes representados
 por ecuaciones diferenciales ordinarias.
 Esta necesidad surge a partir de el hecho de que la mayoría de los integradores
 númericos, necesarios para la simulación de un modelo Modelica, esperan
 modelos respresentados mediante eucaciones diferenciales ordinarias.
 También presentamos el algoritmo de Tarjan como el más adecuado para resolver
 la tarea de causalizaión de ecuaciones, es decir la transformación de ecuacione
s diferenciales algebraicas en ecuaciones diferenciales ordinarias.
 Por último introdujimos el compilador 
\shape italic
ModelicaCC
\shape default
, su arquitectura general y los diferentes componentes que implementan cada
 una de las etapas de compilación.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Estudiamos e implementamos tres estrategias distintas para resolver el problema
 de causalización analizando la complejidad computacional de cada una de
 ellas.
 La aplicación del algoritmo de Tarjan conlleva el cálculo de un enparejamiento
 sobre el grafo lo cual tiene un costo cuadrático con respecto a los vértices.
 Basándonos en una versión simplificada del algoritmo de Tarjan introdujimos
 una nueva formulación del algorítmo (Sección 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Optimización"

\end_inset

) que permite llevar a cabo la causalización en tiempo logarítmico cuando
 el modelo no presenta lazos algebraicos.
 Este algoritmo resultó una optimización en todos los casos, ya que para
 los modelos que sí presentan bucles algebraicos, el algoritmo reduce el
 tamaño del grafo eliminando (y causalizando) los vértices que no pertenecen
 a algún bucle, para luego aplicar el algoritmo de Tarjan calculando el
 emparejamiento sobre un grafo más pequeño.
\end_layout

\begin_layout Standard
La implementación de las estrategías de causalización se realizó utilizando
 librerías abiertas como la biblioteca Boost Graph utilizada para la implementac
ión del algoritmo de Tarjan, así como también para la representacion de
 los grafos y la biblioteca GiNaC para manipulación simbólica.
 
\end_layout

\begin_layout Standard
En el capítulo 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Ejemplos"

\end_inset

 presentamos dos ejemplos del campo eléctrico demostrando que el algoritmo
 produce un resultado correcto tanto ante la presencia o ausencia de lazos
 algebraicos.
\end_layout

\begin_layout Standard
Luego en el capítulo 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Prueba-de-eficiencia"

\end_inset

 se presentó un ejemplo que permite ver más claramente de qué manera la
 inclusión del algoritmo simple resulta en una optimización del proceso
 de causalización.
 
\end_layout

\begin_layout Standard
Por último, se incluyó el detalle de los tests unitarios escritos para validar
 los diferentes componentes desarrollados durante esta tesina.
\end_layout

\begin_layout Section
Trabajo a futuro
\end_layout

\begin_layout Standard
Algunos puntos quedan como trabajo a futuro de esta tesina:
\end_layout

\begin_layout Itemize
Singularidades estructurales: La transformación de ecuaciones diferenciales
 algebráicas en ecuaciones diferenciales ordinarias no siempre puede ser
 llevada a cabo utilizando los algoritmos presentados en este trabajo.
 Ciertos modelos presentan lo que se conoce como 
\begin_inset Quotes eld
\end_inset

singularidad estructural
\begin_inset Quotes erd
\end_inset

 lo que llevará al algoritmo de Tarjan (o sus variantes) a fallar debido
 a que algunos nodos quedan desconectados.
 En este caso debe ser aplicado previamente el algoritmo de Pantelides 
\begin_inset CommandInset citation
LatexCommand citep
key "Pan88"

\end_inset

 para transformar al sistema en uno que sí se pueda causalizar.
\end_layout

\begin_layout Itemize
Otro punto a tratar es la resolución de lazos algebraicos.
 Los algoritmos aquí presentados se encargan de detectar e identificar las
 variables y ecuaciones que deben ser resueltas en conjunto pero este lazo
 puede ser de gran tamaño.
 Una opción para reducir el tamaño del lazo es aplicar la técnica conocida
 como Tearing 
\begin_inset CommandInset citation
LatexCommand citep
key "CK06"

\end_inset

 la cual considera conocida una variable del lazo y trata de despejar las
 otras a partir de ésta.
 En la presente implementación esta técnica no es utilizado por lo cual
 los lazo algebraicos quedan del tamaño con el cual son identificados.
\end_layout

\begin_layout Itemize
Causalización de ecuaciones for sin expansión: En esta versión del causalizador
 de ecuaciones las estructuras repetitivas como las ecuaciones for se expanden.
 Esta solución no es eficiente para modelo de gran escala.
 En 
\begin_inset CommandInset citation
LatexCommand citep
key "lsmodelica"

\end_inset

 se plantea una versión vectorial del algoritmo de Tarjan la cual permite
 realizar la causalización de ecuaciones sin la necesidad de expandir las
 estructuras repetitivas.
 La implementación de dicho algoritmo vectorial queda pendiente para futuras
 versiones del causalizador.
\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
bibfiles "bibliography"
options "plainnat"

\end_inset


\end_layout

\end_body
\end_document
